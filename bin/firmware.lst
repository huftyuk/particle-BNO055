
/Users/nrobinson/particle/particle-BNO055/bin/firmware.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00002488  080a0018  080a0018  00008018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a24a0  0000c000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000004  20000300  080a24a4  00010300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          000005d0  20000304  20000304  00018304  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a24a8  080a24a8  000124a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a24d0  080a24d0  000124d0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   0009a2d9  00000000  00000000  000124d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00013764  00000000  00000000  000ac7ad  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000d571  00000000  00000000  000bff11  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001a20  00000000  00000000  000cd482  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00002ca0  00000000  00000000  000ceea2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  000278f2  00000000  00000000  000d1b42  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0002912e  00000000  00000000  000f9434  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0007e643  00000000  00000000  00122562  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00007bb8  00000000  00000000  001a0ba8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	b0 21 0a 08                                         .!..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f002 f891 	bl	80a2154 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f002 f896 	bl	80a216a <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a24a4 	.word	0x080a24a4
 80a004c:	20000304 	.word	0x20000304
 80a0050:	20000304 	.word	0x20000304
 80a0054:	200008d4 	.word	0x200008d4
 80a0058:	200008d4 	.word	0x200008d4

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f001 f9cf 	bl	80a1400 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a242c 	.word	0x080a242c
 80a0084:	080a2498 	.word	0x080a2498

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 b834 	b.w	80a00f4 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f000 f85f 	bl	80a0150 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f001 b99d 	b.w	80a13d4 <_post_loop>

080a009a <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009a:	f000 bbd1 	b.w	80a0840 <free>

080a009e <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a009e:	7800      	ldrb	r0, [r0, #0]
 80a00a0:	fab0 f080 	clz	r0, r0
 80a00a4:	0940      	lsrs	r0, r0, #5
 80a00a6:	4770      	bx	lr

080a00a8 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00a8:	2301      	movs	r3, #1
 80a00aa:	7003      	strb	r3, [r0, #0]
 80a00ac:	4770      	bx	lr
	...

080a00b0 <_GLOBAL__sub_I__ZN7OneWireC2Et>:
        cdata <<= 1;
        crc ^= cdata;
    }

    return crc;
}
 80a00b0:	b508      	push	{r3, lr}
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a00b2:	4b09      	ldr	r3, [pc, #36]	; (80a00d8 <_GLOBAL__sub_I__ZN7OneWireC2Et+0x28>)
 80a00b4:	2200      	movs	r2, #0
 80a00b6:	4909      	ldr	r1, [pc, #36]	; (80a00dc <_GLOBAL__sub_I__ZN7OneWireC2Et+0x2c>)
 80a00b8:	701a      	strb	r2, [r3, #0]
 80a00ba:	2301      	movs	r3, #1
 80a00bc:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a00be:	4908      	ldr	r1, [pc, #32]	; (80a00e0 <_GLOBAL__sub_I__ZN7OneWireC2Et+0x30>)
 80a00c0:	700a      	strb	r2, [r1, #0]
 80a00c2:	4a08      	ldr	r2, [pc, #32]	; (80a00e4 <_GLOBAL__sub_I__ZN7OneWireC2Et+0x34>)
 80a00c4:	7013      	strb	r3, [r2, #0]
 80a00c6:	4b08      	ldr	r3, [pc, #32]	; (80a00e8 <_GLOBAL__sub_I__ZN7OneWireC2Et+0x38>)
 80a00c8:	2202      	movs	r2, #2
 80a00ca:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a00cc:	f000 fab6 	bl	80a063c <HAL_Pin_Map>
 80a00d0:	4b06      	ldr	r3, [pc, #24]	; (80a00ec <_GLOBAL__sub_I__ZN7OneWireC2Et+0x3c>)
 80a00d2:	6018      	str	r0, [r3, #0]
 80a00d4:	bd08      	pop	{r3, pc}
 80a00d6:	bf00      	nop
 80a00d8:	2000030b 	.word	0x2000030b
 80a00dc:	20000310 	.word	0x20000310
 80a00e0:	20000309 	.word	0x20000309
 80a00e4:	2000030a 	.word	0x2000030a
 80a00e8:	20000308 	.word	0x20000308
 80a00ec:	2000030c 	.word	0x2000030c

080a00f0 <_ZN15Adafruit_Sensor15enableAutoRangeEb>:
  // Constructor(s)
  Adafruit_Sensor() {}
  virtual ~Adafruit_Sensor() {}

  // These must be defined by the subclass
  virtual void enableAutoRange(bool enabled) {};
 80a00f0:	4770      	bx	lr

080a00f2 <_ZN15Adafruit_BNO055D1Ev>:

    uint16_t accel_radius;
    uint16_t mag_radius;
} adafruit_bno055_offsets_t;

class Adafruit_BNO055 : public Adafruit_Sensor
 80a00f2:	4770      	bx	lr

080a00f4 <setup>:
SYSTEM_THREAD(ENABLED);

Adafruit_BNO055 bno = Adafruit_BNO055(55);

void setup(void)
{
 80a00f4:	b508      	push	{r3, lr}
        Serial.begin(9600);
 80a00f6:	f001 f8c3 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a00fa:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a00fe:	f001 f8a5 	bl	80a124c <_ZN9USBSerial5beginEl>
        Serial.println("Orientation Sensor Test");
 80a0102:	f001 f8bd 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a0106:	490e      	ldr	r1, [pc, #56]	; (80a0140 <setup+0x4c>)
 80a0108:	f000 fd0f 	bl	80a0b2a <_ZN5Print7printlnEPKc>
        Serial.println("");
 80a010c:	f001 f8b8 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a0110:	490c      	ldr	r1, [pc, #48]	; (80a0144 <setup+0x50>)
 80a0112:	f000 fd0a 	bl	80a0b2a <_ZN5Print7printlnEPKc>

        /* Initialise the sensor */
        if(!bno.begin())
 80a0116:	480c      	ldr	r0, [pc, #48]	; (80a0148 <setup+0x54>)
 80a0118:	210c      	movs	r1, #12
 80a011a:	f000 f935 	bl	80a0388 <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE>
 80a011e:	b928      	cbnz	r0, 80a012c <setup+0x38>
        {
                /* There was a problem detecting the BNO055 ... check your connections */
                Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
 80a0120:	f001 f8ae 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a0124:	4909      	ldr	r1, [pc, #36]	; (80a014c <setup+0x58>)
 80a0126:	f000 fced 	bl	80a0b04 <_ZN5Print5printEPKc>
        Serial.begin(9600);
        Serial.println("Orientation Sensor Test");
        Serial.println("");

        /* Initialise the sensor */
        if(!bno.begin())
 80a012a:	e7fe      	b.n	80a012a <setup+0x36>
                /* There was a problem detecting the BNO055 ... check your connections */
                Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
                while(1) ;
        }

        delay(1000);
 80a012c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0130:	f000 fb8e 	bl	80a0850 <delay>

        bno.setExtCrystalUse(true);
}
 80a0134:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
                while(1) ;
        }

        delay(1000);

        bno.setExtCrystalUse(true);
 80a0138:	4803      	ldr	r0, [pc, #12]	; (80a0148 <setup+0x54>)
 80a013a:	2101      	movs	r1, #1
 80a013c:	f000 b8e2 	b.w	80a0304 <_ZN15Adafruit_BNO05516setExtCrystalUseEb>
 80a0140:	080a21c4 	.word	0x080a21c4
 80a0144:	080a22be 	.word	0x080a22be
 80a0148:	20000320 	.word	0x20000320
 80a014c:	080a21dc 	.word	0x080a21dc

080a0150 <loop>:
}

void loop(void)
{
 80a0150:	b530      	push	{r4, r5, lr}
 80a0152:	b08d      	sub	sp, #52	; 0x34
        /* Get a new sensor event */
        sensors_event_t event;
        bno.getEvent(&event);
 80a0154:	a903      	add	r1, sp, #12
 80a0156:	4820      	ldr	r0, [pc, #128]	; (80a01d8 <loop+0x88>)
 80a0158:	f000 fa16 	bl	80a0588 <_ZN15Adafruit_BNO0558getEventEP15sensors_event_t>

        /* Display the floating point data */
        Serial.print("X: ");
 80a015c:	f001 f890 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a0160:	491e      	ldr	r1, [pc, #120]	; (80a01dc <loop+0x8c>)
 80a0162:	f000 fccf 	bl	80a0b04 <_ZN5Print5printEPKc>
        Serial.print(event.orientation.x, 4);
 80a0166:	f001 f88b 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a016a:	4605      	mov	r5, r0
 80a016c:	9808      	ldr	r0, [sp, #32]
 80a016e:	f001 fc5d 	bl	80a1a2c <__aeabi_f2d>
 80a0172:	2404      	movs	r4, #4
 80a0174:	4602      	mov	r2, r0
 80a0176:	460b      	mov	r3, r1
 80a0178:	9400      	str	r4, [sp, #0]
 80a017a:	4628      	mov	r0, r5
 80a017c:	f000 fdd4 	bl	80a0d28 <_ZN5Print5printEdi>
        Serial.print("\tY: ");
 80a0180:	f001 f87e 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a0184:	4916      	ldr	r1, [pc, #88]	; (80a01e0 <loop+0x90>)
 80a0186:	f000 fcbd 	bl	80a0b04 <_ZN5Print5printEPKc>
        Serial.print(event.orientation.y, 4);
 80a018a:	f001 f879 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a018e:	4605      	mov	r5, r0
 80a0190:	9809      	ldr	r0, [sp, #36]	; 0x24
 80a0192:	f001 fc4b 	bl	80a1a2c <__aeabi_f2d>
 80a0196:	9400      	str	r4, [sp, #0]
 80a0198:	4602      	mov	r2, r0
 80a019a:	460b      	mov	r3, r1
 80a019c:	4628      	mov	r0, r5
 80a019e:	f000 fdc3 	bl	80a0d28 <_ZN5Print5printEdi>
        Serial.print("\tZ: ");
 80a01a2:	f001 f86d 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a01a6:	490f      	ldr	r1, [pc, #60]	; (80a01e4 <loop+0x94>)
 80a01a8:	f000 fcac 	bl	80a0b04 <_ZN5Print5printEPKc>
        Serial.print(event.orientation.z, 4);
 80a01ac:	f001 f868 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a01b0:	4605      	mov	r5, r0
 80a01b2:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a01b4:	f001 fc3a 	bl	80a1a2c <__aeabi_f2d>
 80a01b8:	9400      	str	r4, [sp, #0]
 80a01ba:	4602      	mov	r2, r0
 80a01bc:	460b      	mov	r3, r1
 80a01be:	4628      	mov	r0, r5
 80a01c0:	f000 fdb2 	bl	80a0d28 <_ZN5Print5printEdi>
        Serial.println("");
 80a01c4:	f001 f85c 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a01c8:	4907      	ldr	r1, [pc, #28]	; (80a01e8 <loop+0x98>)
 80a01ca:	f000 fcae 	bl	80a0b2a <_ZN5Print7printlnEPKc>

        delay(100);
 80a01ce:	2064      	movs	r0, #100	; 0x64
 80a01d0:	f000 fb3e 	bl	80a0850 <delay>
}
 80a01d4:	b00d      	add	sp, #52	; 0x34
 80a01d6:	bd30      	pop	{r4, r5, pc}
 80a01d8:	20000320 	.word	0x20000320
 80a01dc:	080a2219 	.word	0x080a2219
 80a01e0:	080a221d 	.word	0x080a221d
 80a01e4:	080a2222 	.word	0x080a2222
 80a01e8:	080a22be 	.word	0x080a22be

080a01ec <_ZN15Adafruit_BNO055D0Ev>:
 80a01ec:	b510      	push	{r4, lr}
 80a01ee:	4604      	mov	r4, r0
 80a01f0:	f7ff ff53 	bl	80a009a <_ZdlPv>
 80a01f4:	4620      	mov	r0, r4
 80a01f6:	bd10      	pop	{r4, pc}

080a01f8 <_GLOBAL__sub_I_SystemMode>:
 80a01f8:	b538      	push	{r3, r4, r5, lr}
 80a01fa:	4b12      	ldr	r3, [pc, #72]	; (80a0244 <_GLOBAL__sub_I_SystemMode+0x4c>)
 80a01fc:	2400      	movs	r4, #0
 80a01fe:	701c      	strb	r4, [r3, #0]
 80a0200:	4b11      	ldr	r3, [pc, #68]	; (80a0248 <_GLOBAL__sub_I_SystemMode+0x50>)
 80a0202:	2501      	movs	r5, #1
 80a0204:	701d      	strb	r5, [r3, #0]
 80a0206:	4b11      	ldr	r3, [pc, #68]	; (80a024c <_GLOBAL__sub_I_SystemMode+0x54>)
 80a0208:	2202      	movs	r2, #2
 80a020a:	701c      	strb	r4, [r3, #0]
 80a020c:	4b10      	ldr	r3, [pc, #64]	; (80a0250 <_GLOBAL__sub_I_SystemMode+0x58>)
 80a020e:	701d      	strb	r5, [r3, #0]
 80a0210:	4b10      	ldr	r3, [pc, #64]	; (80a0254 <_GLOBAL__sub_I_SystemMode+0x5c>)
 80a0212:	701a      	strb	r2, [r3, #0]
 80a0214:	f000 fa12 	bl	80a063c <HAL_Pin_Map>
 80a0218:	4b0f      	ldr	r3, [pc, #60]	; (80a0258 <_GLOBAL__sub_I_SystemMode+0x60>)
 80a021a:	6018      	str	r0, [r3, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a021c:	2003      	movs	r0, #3
 80a021e:	f000 faef 	bl	80a0800 <set_system_mode>
#include "OneWire.h"
#include "particle-BNO055.h"
#include "Particle.h"

SYSTEM_MODE(MANUAL);
SYSTEM_THREAD(ENABLED);
 80a0222:	4621      	mov	r1, r4

Adafruit_BNO055 bno = Adafruit_BNO055(55);
 80a0224:	4c0d      	ldr	r4, [pc, #52]	; (80a025c <_GLOBAL__sub_I_SystemMode+0x64>)
#include "OneWire.h"
#include "particle-BNO055.h"
#include "Particle.h"

SYSTEM_MODE(MANUAL);
SYSTEM_THREAD(ENABLED);
 80a0226:	4628      	mov	r0, r5
 80a0228:	f000 fafa 	bl	80a0820 <system_thread_set_state>

Adafruit_BNO055 bno = Adafruit_BNO055(55);
 80a022c:	4620      	mov	r0, r4
 80a022e:	2137      	movs	r1, #55	; 0x37
 80a0230:	2228      	movs	r2, #40	; 0x28
 80a0232:	f000 f839 	bl	80a02a8 <_ZN15Adafruit_BNO055C1Elh>
 80a0236:	4620      	mov	r0, r4
        Serial.print("\tZ: ");
        Serial.print(event.orientation.z, 4);
        Serial.println("");

        delay(100);
}
 80a0238:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#include "Particle.h"

SYSTEM_MODE(MANUAL);
SYSTEM_THREAD(ENABLED);

Adafruit_BNO055 bno = Adafruit_BNO055(55);
 80a023c:	4908      	ldr	r1, [pc, #32]	; (80a0260 <_GLOBAL__sub_I_SystemMode+0x68>)
 80a023e:	4a09      	ldr	r2, [pc, #36]	; (80a0264 <_GLOBAL__sub_I_SystemMode+0x6c>)
 80a0240:	f001 b99a 	b.w	80a1578 <__aeabi_atexit>
 80a0244:	2000031b 	.word	0x2000031b
 80a0248:	2000031c 	.word	0x2000031c
 80a024c:	20000319 	.word	0x20000319
 80a0250:	2000031a 	.word	0x2000031a
 80a0254:	20000318 	.word	0x20000318
 80a0258:	20000314 	.word	0x20000314
 80a025c:	20000320 	.word	0x20000320
 80a0260:	080a00f3 	.word	0x080a00f3
 80a0264:	20000304 	.word	0x20000304

080a0268 <_ZN15Adafruit_BNO0559getSensorEP8sensor_t>:
/*!
    @brief  Provides the sensor_t data for this sensor
*/
/**************************************************************************/
void Adafruit_BNO055::getSensor(sensor_t *sensor)
{
 80a0268:	b538      	push	{r3, r4, r5, lr}
 80a026a:	460c      	mov	r4, r1
 80a026c:	4605      	mov	r5, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
 80a026e:	2228      	movs	r2, #40	; 0x28
 80a0270:	4608      	mov	r0, r1
 80a0272:	2100      	movs	r1, #0
 80a0274:	f001 ff79 	bl	80a216a <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "BNO055", sizeof(sensor->name) - 1);
 80a0278:	220b      	movs	r2, #11
 80a027a:	4620      	mov	r0, r4
 80a027c:	4908      	ldr	r1, [pc, #32]	; (80a02a0 <_ZN15Adafruit_BNO0559getSensorEP8sensor_t+0x38>)
 80a027e:	f001 ff84 	bl	80a218a <strncpy>
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a0282:	2300      	movs	r3, #0
  sensor->version     = 1;
 80a0284:	2201      	movs	r2, #1
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "BNO055", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a0286:	72e3      	strb	r3, [r4, #11]
  sensor->version     = 1;
 80a0288:	60e2      	str	r2, [r4, #12]
  sensor->sensor_id   = _sensorID;
 80a028a:	68aa      	ldr	r2, [r5, #8]
  sensor->type        = SENSOR_TYPE_ORIENTATION;
  sensor->min_delay   = 0;
 80a028c:	6263      	str	r3, [r4, #36]	; 0x24
  sensor->max_value   = 0.0F;
 80a028e:	2300      	movs	r3, #0
 80a0290:	61a3      	str	r3, [r4, #24]
  sensor->min_value   = 0.0F;
 80a0292:	61e3      	str	r3, [r4, #28]
  sensor->resolution  = 0.01F;
 80a0294:	4b03      	ldr	r3, [pc, #12]	; (80a02a4 <_ZN15Adafruit_BNO0559getSensorEP8sensor_t+0x3c>)

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "BNO055", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name)- 1] = 0;
  sensor->version     = 1;
  sensor->sensor_id   = _sensorID;
 80a0296:	6122      	str	r2, [r4, #16]
  sensor->type        = SENSOR_TYPE_ORIENTATION;
 80a0298:	2203      	movs	r2, #3
 80a029a:	6162      	str	r2, [r4, #20]
  sensor->min_delay   = 0;
  sensor->max_value   = 0.0F;
  sensor->min_value   = 0.0F;
  sensor->resolution  = 0.01F;
 80a029c:	6223      	str	r3, [r4, #32]
 80a029e:	bd38      	pop	{r3, r4, r5, pc}
 80a02a0:	080a2227 	.word	0x080a2227
 80a02a4:	3c23d70a 	.word	0x3c23d70a

080a02a8 <_ZN15Adafruit_BNO055C1Elh>:
/**************************************************************************/
/*!
    @brief  Instantiates a new Adafruit_BNO055 class
*/
/**************************************************************************/
Adafruit_BNO055::Adafruit_BNO055(int32_t sensorID, uint8_t address)
 80a02a8:	b510      	push	{r4, lr}
 80a02aa:	4c02      	ldr	r4, [pc, #8]	; (80a02b4 <_ZN15Adafruit_BNO055C1Elh+0xc>)
{
  _sensorID = sensorID;
 80a02ac:	6081      	str	r1, [r0, #8]
/**************************************************************************/
/*!
    @brief  Instantiates a new Adafruit_BNO055 class
*/
/**************************************************************************/
Adafruit_BNO055::Adafruit_BNO055(int32_t sensorID, uint8_t address)
 80a02ae:	6004      	str	r4, [r0, #0]
{
  _sensorID = sensorID;
  _address = address;
 80a02b0:	7142      	strb	r2, [r0, #5]
}
 80a02b2:	bd10      	pop	{r4, pc}
 80a02b4:	080a2238 	.word	0x080a2238

080a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>:
/*!
    @brief  Writes an 8 bit value over I2C
*/
/**************************************************************************/
bool Adafruit_BNO055::write8(adafruit_bno055_reg_t reg, byte value)
{
 80a02b8:	b570      	push	{r4, r5, r6, lr}
 80a02ba:	4606      	mov	r6, r0
 80a02bc:	4614      	mov	r4, r2
 80a02be:	460d      	mov	r5, r1
  Wire.beginTransmission(_address);
 80a02c0:	f001 f8ea 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a02c4:	7971      	ldrb	r1, [r6, #5]
 80a02c6:	f000 fb77 	bl	80a09b8 <_ZN7TwoWire17beginTransmissionEh>

    Wire.write((uint8_t)reg);
 80a02ca:	f001 f8e5 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a02ce:	6803      	ldr	r3, [r0, #0]
 80a02d0:	4629      	mov	r1, r5
 80a02d2:	689b      	ldr	r3, [r3, #8]
 80a02d4:	4798      	blx	r3
    Wire.write((uint8_t)value);
 80a02d6:	f001 f8df 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a02da:	6803      	ldr	r3, [r0, #0]
 80a02dc:	4621      	mov	r1, r4
 80a02de:	689b      	ldr	r3, [r3, #8]
 80a02e0:	4798      	blx	r3

  Wire.endTransmission();
 80a02e2:	f001 f8d9 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a02e6:	f000 fb6f 	bl	80a09c8 <_ZN7TwoWire15endTransmissionEv>

  /* ToDo: Check for error! */
  return true;
}
 80a02ea:	2001      	movs	r0, #1
 80a02ec:	bd70      	pop	{r4, r5, r6, pc}

080a02ee <_ZN15Adafruit_BNO0557setModeENS_24adafruit_bno055_opmode_tE>:
/*!
    @brief  Puts the chip in the specified operating mode
*/
/**************************************************************************/
void Adafruit_BNO055::setMode(adafruit_bno055_opmode_t mode)
{
 80a02ee:	b508      	push	{r3, lr}
 80a02f0:	460a      	mov	r2, r1
  _mode = mode;
 80a02f2:	7301      	strb	r1, [r0, #12]
  write8(BNO055_OPR_MODE_ADDR, _mode);
 80a02f4:	213d      	movs	r1, #61	; 0x3d
 80a02f6:	f7ff ffdf 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  delay(30);
}
 80a02fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
/**************************************************************************/
void Adafruit_BNO055::setMode(adafruit_bno055_opmode_t mode)
{
  _mode = mode;
  write8(BNO055_OPR_MODE_ADDR, _mode);
  delay(30);
 80a02fe:	201e      	movs	r0, #30
 80a0300:	f000 baa6 	b.w	80a0850 <delay>

080a0304 <_ZN15Adafruit_BNO05516setExtCrystalUseEb>:
/*!
    @brief  Use the external 32.768KHz crystal
*/
/**************************************************************************/
void Adafruit_BNO055::setExtCrystalUse(boolean usextal)
{
 80a0304:	b570      	push	{r4, r5, r6, lr}
 80a0306:	4604      	mov	r4, r0
 80a0308:	460d      	mov	r5, r1
  adafruit_bno055_opmode_t modeback = _mode;

  /* Switch to config mode (just in case since this is the default) */
  setMode(OPERATION_MODE_CONFIG);
 80a030a:	2100      	movs	r1, #0
    @brief  Use the external 32.768KHz crystal
*/
/**************************************************************************/
void Adafruit_BNO055::setExtCrystalUse(boolean usextal)
{
  adafruit_bno055_opmode_t modeback = _mode;
 80a030c:	7b06      	ldrb	r6, [r0, #12]

  /* Switch to config mode (just in case since this is the default) */
  setMode(OPERATION_MODE_CONFIG);
 80a030e:	f7ff ffee 	bl	80a02ee <_ZN15Adafruit_BNO0557setModeENS_24adafruit_bno055_opmode_tE>
  delay(25);
 80a0312:	2019      	movs	r0, #25
 80a0314:	f000 fa9c 	bl	80a0850 <delay>
  write8(BNO055_PAGE_ID_ADDR, 0);
 80a0318:	2107      	movs	r1, #7
 80a031a:	4620      	mov	r0, r4
 80a031c:	2200      	movs	r2, #0
 80a031e:	f7ff ffcb 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  if (usextal) {
    write8(BNO055_SYS_TRIGGER_ADDR, 0x80);
 80a0322:	4620      	mov	r0, r4
 80a0324:	213f      	movs	r1, #63	; 0x3f

  /* Switch to config mode (just in case since this is the default) */
  setMode(OPERATION_MODE_CONFIG);
  delay(25);
  write8(BNO055_PAGE_ID_ADDR, 0);
  if (usextal) {
 80a0326:	b10d      	cbz	r5, 80a032c <_ZN15Adafruit_BNO05516setExtCrystalUseEb+0x28>
    write8(BNO055_SYS_TRIGGER_ADDR, 0x80);
 80a0328:	2280      	movs	r2, #128	; 0x80
 80a032a:	e000      	b.n	80a032e <_ZN15Adafruit_BNO05516setExtCrystalUseEb+0x2a>
  } else {
    write8(BNO055_SYS_TRIGGER_ADDR, 0x00);
 80a032c:	462a      	mov	r2, r5
 80a032e:	f7ff ffc3 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  }
  delay(10);
 80a0332:	200a      	movs	r0, #10
 80a0334:	f000 fa8c 	bl	80a0850 <delay>
  /* Set the requested operating mode (see section 3.3) */
  setMode(modeback);
 80a0338:	4620      	mov	r0, r4
 80a033a:	4631      	mov	r1, r6
 80a033c:	f7ff ffd7 	bl	80a02ee <_ZN15Adafruit_BNO0557setModeENS_24adafruit_bno055_opmode_tE>
  delay(20);
}
 80a0340:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    write8(BNO055_SYS_TRIGGER_ADDR, 0x00);
  }
  delay(10);
  /* Set the requested operating mode (see section 3.3) */
  setMode(modeback);
  delay(20);
 80a0344:	2014      	movs	r0, #20
 80a0346:	f000 ba83 	b.w	80a0850 <delay>

080a034a <_ZN15Adafruit_BNO0555read8ENS_21adafruit_bno055_reg_tE>:
/*!
    @brief  Reads an 8 bit value over I2C
*/
/**************************************************************************/
byte Adafruit_BNO055::read8(adafruit_bno055_reg_t reg )
{
 80a034a:	b538      	push	{r3, r4, r5, lr}
 80a034c:	4604      	mov	r4, r0
 80a034e:	460d      	mov	r5, r1
  byte value = 0;

  Wire.beginTransmission(_address);
 80a0350:	f001 f8a2 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0354:	7961      	ldrb	r1, [r4, #5]
 80a0356:	f000 fb2f 	bl	80a09b8 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((uint8_t)reg);
 80a035a:	f001 f89d 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a035e:	6803      	ldr	r3, [r0, #0]
 80a0360:	4629      	mov	r1, r5
 80a0362:	689b      	ldr	r3, [r3, #8]
 80a0364:	4798      	blx	r3
  Wire.endTransmission();
 80a0366:	f001 f897 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a036a:	f000 fb2d 	bl	80a09c8 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(_address, (byte)1);
 80a036e:	f001 f893 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0372:	7961      	ldrb	r1, [r4, #5]
 80a0374:	2201      	movs	r2, #1
 80a0376:	f000 fb1c 	bl	80a09b2 <_ZN7TwoWire11requestFromEhh>
  value = Wire.read();
 80a037a:	f001 f88d 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a037e:	6803      	ldr	r3, [r0, #0]
 80a0380:	695b      	ldr	r3, [r3, #20]
 80a0382:	4798      	blx	r3

  return value;
}
 80a0384:	b2c0      	uxtb	r0, r0
 80a0386:	bd38      	pop	{r3, r4, r5, pc}

080a0388 <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE>:
/*!
    @brief  Sets up the HW
*/
/**************************************************************************/
bool Adafruit_BNO055::begin(adafruit_bno055_opmode_t mode)
{
 80a0388:	b538      	push	{r3, r4, r5, lr}
 80a038a:	4604      	mov	r4, r0
 80a038c:	460d      	mov	r5, r1
  /* Enable I2C */
  Wire.begin();
 80a038e:	f001 f883 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0392:	f000 faff 	bl	80a0994 <_ZN7TwoWire5beginEv>
#ifdef ESP8266
  Wire.setClockStretchLimit(1000); // Allow for 1000us of clock stretching
#endif

  /* Make sure we have the right device */
  uint8_t id = read8(BNO055_CHIP_ID_ADDR);
 80a0396:	4620      	mov	r0, r4
 80a0398:	2100      	movs	r1, #0
 80a039a:	f7ff ffd6 	bl	80a034a <_ZN15Adafruit_BNO0555read8ENS_21adafruit_bno055_reg_tE>
  if(id != BNO055_ID)
 80a039e:	28a0      	cmp	r0, #160	; 0xa0
 80a03a0:	d109      	bne.n	80a03b6 <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE+0x2e>
      return false;  // still not? ok bail
    }
  }

  /* Switch to config mode (just in case since this is the default) */
  setMode(OPERATION_MODE_CONFIG);
 80a03a2:	4620      	mov	r0, r4
 80a03a4:	2100      	movs	r1, #0
 80a03a6:	f7ff ffa2 	bl	80a02ee <_ZN15Adafruit_BNO0557setModeENS_24adafruit_bno055_opmode_tE>

  /* Reset */
  write8(BNO055_SYS_TRIGGER_ADDR, 0x20);
 80a03aa:	4620      	mov	r0, r4
 80a03ac:	213f      	movs	r1, #63	; 0x3f
 80a03ae:	2220      	movs	r2, #32
 80a03b0:	f7ff ff82 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  while (read8(BNO055_CHIP_ID_ADDR) != BNO055_ID)
 80a03b4:	e00b      	b.n	80a03ce <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE+0x46>

  /* Make sure we have the right device */
  uint8_t id = read8(BNO055_CHIP_ID_ADDR);
  if(id != BNO055_ID)
  {
    delay(1000); // hold on for boot
 80a03b6:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a03ba:	f000 fa49 	bl	80a0850 <delay>
    id = read8(BNO055_CHIP_ID_ADDR);
 80a03be:	4620      	mov	r0, r4
 80a03c0:	2100      	movs	r1, #0
 80a03c2:	f7ff ffc2 	bl	80a034a <_ZN15Adafruit_BNO0555read8ENS_21adafruit_bno055_reg_tE>
    if(id != BNO055_ID) {
 80a03c6:	28a0      	cmp	r0, #160	; 0xa0
 80a03c8:	d0eb      	beq.n	80a03a2 <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE+0x1a>
      return false;  // still not? ok bail
 80a03ca:	2000      	movs	r0, #0
  /* Set the requested operating mode (see section 3.3) */
  setMode(mode);
  delay(20);

  return true;
}
 80a03cc:	bd38      	pop	{r3, r4, r5, pc}
  /* Switch to config mode (just in case since this is the default) */
  setMode(OPERATION_MODE_CONFIG);

  /* Reset */
  write8(BNO055_SYS_TRIGGER_ADDR, 0x20);
  while (read8(BNO055_CHIP_ID_ADDR) != BNO055_ID)
 80a03ce:	4620      	mov	r0, r4
 80a03d0:	2100      	movs	r1, #0
 80a03d2:	f7ff ffba 	bl	80a034a <_ZN15Adafruit_BNO0555read8ENS_21adafruit_bno055_reg_tE>
 80a03d6:	28a0      	cmp	r0, #160	; 0xa0
 80a03d8:	d003      	beq.n	80a03e2 <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE+0x5a>
  {
    delay(10);
 80a03da:	200a      	movs	r0, #10
 80a03dc:	f000 fa38 	bl	80a0850 <delay>
 80a03e0:	e7f5      	b.n	80a03ce <_ZN15Adafruit_BNO0555beginENS_24adafruit_bno055_opmode_tE+0x46>
  }
  delay(50);
 80a03e2:	2032      	movs	r0, #50	; 0x32
 80a03e4:	f000 fa34 	bl	80a0850 <delay>

  /* Set to normal power mode */
  write8(BNO055_PWR_MODE_ADDR, POWER_MODE_NORMAL);
 80a03e8:	213e      	movs	r1, #62	; 0x3e
 80a03ea:	2200      	movs	r2, #0
 80a03ec:	4620      	mov	r0, r4
 80a03ee:	f7ff ff63 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  delay(10);
 80a03f2:	200a      	movs	r0, #10
 80a03f4:	f000 fa2c 	bl	80a0850 <delay>

  write8(BNO055_PAGE_ID_ADDR, 0);
 80a03f8:	4620      	mov	r0, r4
 80a03fa:	2107      	movs	r1, #7
 80a03fc:	2200      	movs	r2, #0
 80a03fe:	f7ff ff5b 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  delay(10);
  write8(BNO055_AXIS_MAP_SIGN_ADDR, REMAP_SIGN_P2); // P0-P7, Default is P1
  delay(10);
  */

  write8(BNO055_SYS_TRIGGER_ADDR, 0x0);
 80a0402:	2200      	movs	r2, #0
 80a0404:	213f      	movs	r1, #63	; 0x3f
 80a0406:	4620      	mov	r0, r4
 80a0408:	f7ff ff56 	bl	80a02b8 <_ZN15Adafruit_BNO0556write8ENS_21adafruit_bno055_reg_tEh>
  delay(10);
 80a040c:	200a      	movs	r0, #10
 80a040e:	f000 fa1f 	bl	80a0850 <delay>
  /* Set the requested operating mode (see section 3.3) */
  setMode(mode);
 80a0412:	4620      	mov	r0, r4
 80a0414:	4629      	mov	r1, r5
 80a0416:	f7ff ff6a 	bl	80a02ee <_ZN15Adafruit_BNO0557setModeENS_24adafruit_bno055_opmode_tE>
  delay(20);
 80a041a:	2014      	movs	r0, #20
 80a041c:	f000 fa18 	bl	80a0850 <delay>

  return true;
 80a0420:	2001      	movs	r0, #1
 80a0422:	bd38      	pop	{r3, r4, r5, pc}

080a0424 <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPhh>:
/*!
    @brief  Reads the specified number of bytes over I2C
*/
/**************************************************************************/
bool Adafruit_BNO055::readLen(adafruit_bno055_reg_t reg, byte * buffer, uint8_t len)
{
 80a0424:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0426:	4605      	mov	r5, r0
 80a0428:	4616      	mov	r6, r2
 80a042a:	461c      	mov	r4, r3
 80a042c:	460f      	mov	r7, r1
  Wire.beginTransmission(_address);
 80a042e:	f001 f833 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0432:	7969      	ldrb	r1, [r5, #5]
 80a0434:	f000 fac0 	bl	80a09b8 <_ZN7TwoWire17beginTransmissionEh>
  Wire.write((uint8_t)reg);
 80a0438:	f001 f82e 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a043c:	6803      	ldr	r3, [r0, #0]
 80a043e:	4639      	mov	r1, r7
 80a0440:	689b      	ldr	r3, [r3, #8]
 80a0442:	4798      	blx	r3
  Wire.endTransmission();
 80a0444:	f001 f828 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0448:	f000 fabe 	bl	80a09c8 <_ZN7TwoWire15endTransmissionEv>
  Wire.requestFrom(_address, (byte)len);
 80a044c:	f001 f824 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0450:	7969      	ldrb	r1, [r5, #5]
 80a0452:	4622      	mov	r2, r4
 80a0454:	f000 faad 	bl	80a09b2 <_ZN7TwoWire11requestFromEhh>
 80a0458:	3c01      	subs	r4, #1
 80a045a:	1e75      	subs	r5, r6, #1
 80a045c:	4434      	add	r4, r6

  for (uint8_t i = 0; i < len; i++)
 80a045e:	42a5      	cmp	r5, r4
 80a0460:	d007      	beq.n	80a0472 <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPhh+0x4e>
  {
      buffer[i] = Wire.read();
 80a0462:	f001 f819 	bl	80a1498 <_Z19__fetch_global_Wirev>
 80a0466:	6803      	ldr	r3, [r0, #0]
 80a0468:	695b      	ldr	r3, [r3, #20]
 80a046a:	4798      	blx	r3
 80a046c:	f805 0f01 	strb.w	r0, [r5, #1]!
 80a0470:	e7f5      	b.n	80a045e <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPhh+0x3a>
  }

  /* ToDo: Check for errors! */
  return true;
}
 80a0472:	2001      	movs	r0, #1
 80a0474:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

080a0478 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE>:
/*!
    @brief  Gets a vector reading from the specified source
*/
/**************************************************************************/
imu::Vector<3> Adafruit_BNO055::getVector(adafruit_vector_type_t vector_type)
{
 80a0478:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a047a:	460e      	mov	r6, r1
 80a047c:	4615      	mov	r5, r2
template <uint8_t N> class Vector
{
public:
    Vector()
    {
        memset(p_vec, 0, sizeof(double)*N);
 80a047e:	2100      	movs	r1, #0
 80a0480:	2218      	movs	r2, #24
 80a0482:	4604      	mov	r4, r0
 80a0484:	f001 fe71 	bl	80a216a <memset>
  imu::Vector<3> xyz;
  uint8_t buffer[6];
  memset (buffer, 0, 6);
 80a0488:	2300      	movs	r3, #0
 80a048a:	9300      	str	r3, [sp, #0]
 80a048c:	f8ad 3004 	strh.w	r3, [sp, #4]

  int16_t x, y, z;
  x = y = z = 0;

  /* Read vector data (6 bytes) */
  readLen((adafruit_bno055_reg_t)vector_type, buffer, 6);
 80a0490:	4630      	mov	r0, r6
 80a0492:	2306      	movs	r3, #6
 80a0494:	4629      	mov	r1, r5
 80a0496:	466a      	mov	r2, sp
 80a0498:	f7ff ffc4 	bl	80a0424 <_ZN15Adafruit_BNO0557readLenENS_21adafruit_bno055_reg_tEPhh>

  x = ((int16_t)buffer[0]) | (((int16_t)buffer[1]) << 8);
 80a049c:	f89d 3000 	ldrb.w	r3, [sp]
 80a04a0:	f89d 0001 	ldrb.w	r0, [sp, #1]
  y = ((int16_t)buffer[2]) | (((int16_t)buffer[3]) << 8);
 80a04a4:	f89d 7003 	ldrb.w	r7, [sp, #3]
  x = y = z = 0;

  /* Read vector data (6 bytes) */
  readLen((adafruit_bno055_reg_t)vector_type, buffer, 6);

  x = ((int16_t)buffer[0]) | (((int16_t)buffer[1]) << 8);
 80a04a8:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  y = ((int16_t)buffer[2]) | (((int16_t)buffer[3]) << 8);
 80a04ac:	f89d 3002 	ldrb.w	r3, [sp, #2]
  z = ((int16_t)buffer[4]) | (((int16_t)buffer[5]) << 8);
 80a04b0:	f89d 6005 	ldrb.w	r6, [sp, #5]

  /* Read vector data (6 bytes) */
  readLen((adafruit_bno055_reg_t)vector_type, buffer, 6);

  x = ((int16_t)buffer[0]) | (((int16_t)buffer[1]) << 8);
  y = ((int16_t)buffer[2]) | (((int16_t)buffer[3]) << 8);
 80a04b4:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
  z = ((int16_t)buffer[4]) | (((int16_t)buffer[5]) << 8);
 80a04b8:	f89d 3004 	ldrb.w	r3, [sp, #4]

  /* Convert the value to an appropriate range (section 3.6.4) */
  /* and assign the value to the Vector type */
  switch(vector_type)
 80a04bc:	2d14      	cmp	r5, #20
  /* Read vector data (6 bytes) */
  readLen((adafruit_bno055_reg_t)vector_type, buffer, 6);

  x = ((int16_t)buffer[0]) | (((int16_t)buffer[1]) << 8);
  y = ((int16_t)buffer[2]) | (((int16_t)buffer[3]) << 8);
  z = ((int16_t)buffer[4]) | (((int16_t)buffer[5]) << 8);
 80a04be:	ea43 2606 	orr.w	r6, r3, r6, lsl #8

  /* Convert the value to an appropriate range (section 3.6.4) */
  /* and assign the value to the Vector type */
  switch(vector_type)
 80a04c2:	d024      	beq.n	80a050e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x96>
 80a04c4:	d803      	bhi.n	80a04ce <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x56>
 80a04c6:	2d08      	cmp	r5, #8
 80a04c8:	d039      	beq.n	80a053e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xc6>
 80a04ca:	2d0e      	cmp	r5, #14
 80a04cc:	e004      	b.n	80a04d8 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x60>
 80a04ce:	2d28      	cmp	r5, #40	; 0x28
 80a04d0:	d035      	beq.n	80a053e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xc6>
 80a04d2:	2d2e      	cmp	r5, #46	; 0x2e
 80a04d4:	d033      	beq.n	80a053e <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xc6>
 80a04d6:	2d1a      	cmp	r5, #26
 80a04d8:	d14c      	bne.n	80a0574 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xfc>
      xyz[1] = ((double)y)/900.0;
      xyz[2] = ((double)z)/900.0;
      break;
    case VECTOR_EULER:
      /* 1 degree = 16 LSB */
      xyz[0] = ((double)x)/16.0;
 80a04da:	b200      	sxth	r0, r0
 80a04dc:	f001 fa94 	bl	80a1a08 <__aeabi_i2d>
 80a04e0:	2200      	movs	r2, #0
 80a04e2:	4b26      	ldr	r3, [pc, #152]	; (80a057c <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x104>)
 80a04e4:	f001 faf6 	bl	80a1ad4 <__aeabi_dmul>
 80a04e8:	e9c4 0100 	strd	r0, r1, [r4]
      xyz[1] = ((double)y)/16.0;
 80a04ec:	b238      	sxth	r0, r7
 80a04ee:	f001 fa8b 	bl	80a1a08 <__aeabi_i2d>
 80a04f2:	2200      	movs	r2, #0
 80a04f4:	4b21      	ldr	r3, [pc, #132]	; (80a057c <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x104>)
 80a04f6:	f001 faed 	bl	80a1ad4 <__aeabi_dmul>
 80a04fa:	e9c4 0102 	strd	r0, r1, [r4, #8]
      xyz[2] = ((double)z)/16.0;
 80a04fe:	b230      	sxth	r0, r6
 80a0500:	f001 fa82 	bl	80a1a08 <__aeabi_i2d>
 80a0504:	2200      	movs	r2, #0
 80a0506:	4b1d      	ldr	r3, [pc, #116]	; (80a057c <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x104>)
 80a0508:	f001 fae4 	bl	80a1ad4 <__aeabi_dmul>
 80a050c:	e030      	b.n	80a0570 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xf8>
      xyz[1] = ((double)y)/16.0;
      xyz[2] = ((double)z)/16.0;
      break;
    case VECTOR_GYROSCOPE:
      /* 1rps = 900 LSB */
      xyz[0] = ((double)x)/900.0;
 80a050e:	b200      	sxth	r0, r0
 80a0510:	f001 fa7a 	bl	80a1a08 <__aeabi_i2d>
 80a0514:	2200      	movs	r2, #0
 80a0516:	4b1a      	ldr	r3, [pc, #104]	; (80a0580 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x108>)
 80a0518:	f001 fc06 	bl	80a1d28 <__aeabi_ddiv>
 80a051c:	e9c4 0100 	strd	r0, r1, [r4]
      xyz[1] = ((double)y)/900.0;
 80a0520:	b238      	sxth	r0, r7
 80a0522:	f001 fa71 	bl	80a1a08 <__aeabi_i2d>
 80a0526:	2200      	movs	r2, #0
 80a0528:	4b15      	ldr	r3, [pc, #84]	; (80a0580 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x108>)
 80a052a:	f001 fbfd 	bl	80a1d28 <__aeabi_ddiv>
 80a052e:	e9c4 0102 	strd	r0, r1, [r4, #8]
      xyz[2] = ((double)z)/900.0;
 80a0532:	b230      	sxth	r0, r6
 80a0534:	f001 fa68 	bl	80a1a08 <__aeabi_i2d>
 80a0538:	2200      	movs	r2, #0
 80a053a:	4b11      	ldr	r3, [pc, #68]	; (80a0580 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x108>)
 80a053c:	e016      	b.n	80a056c <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0xf4>
      break;
    case VECTOR_ACCELEROMETER:
    case VECTOR_LINEARACCEL:
    case VECTOR_GRAVITY:
      /* 1m/s^2 = 100 LSB */
      xyz[0] = ((double)x)/100.0;
 80a053e:	b200      	sxth	r0, r0
 80a0540:	f001 fa62 	bl	80a1a08 <__aeabi_i2d>
 80a0544:	2200      	movs	r2, #0
 80a0546:	4b0f      	ldr	r3, [pc, #60]	; (80a0584 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x10c>)
 80a0548:	f001 fbee 	bl	80a1d28 <__aeabi_ddiv>
 80a054c:	e9c4 0100 	strd	r0, r1, [r4]
      xyz[1] = ((double)y)/100.0;
 80a0550:	b238      	sxth	r0, r7
 80a0552:	f001 fa59 	bl	80a1a08 <__aeabi_i2d>
 80a0556:	2200      	movs	r2, #0
 80a0558:	4b0a      	ldr	r3, [pc, #40]	; (80a0584 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x10c>)
 80a055a:	f001 fbe5 	bl	80a1d28 <__aeabi_ddiv>
 80a055e:	e9c4 0102 	strd	r0, r1, [r4, #8]
      xyz[2] = ((double)z)/100.0;
 80a0562:	b230      	sxth	r0, r6
 80a0564:	f001 fa50 	bl	80a1a08 <__aeabi_i2d>
 80a0568:	4b06      	ldr	r3, [pc, #24]	; (80a0584 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE+0x10c>)
 80a056a:	2200      	movs	r2, #0
 80a056c:	f001 fbdc 	bl	80a1d28 <__aeabi_ddiv>
 80a0570:	e9c4 0104 	strd	r0, r1, [r4, #16]
      break;
  }

  return xyz;
}
 80a0574:	4620      	mov	r0, r4
 80a0576:	b003      	add	sp, #12
 80a0578:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a057a:	bf00      	nop
 80a057c:	3fb00000 	.word	0x3fb00000
 80a0580:	408c2000 	.word	0x408c2000
 80a0584:	40590000 	.word	0x40590000

080a0588 <_ZN15Adafruit_BNO0558getEventEP15sensors_event_t>:
/*!
    @brief  Reads the sensor and returns the data as a sensors_event_t
*/
/**************************************************************************/
bool Adafruit_BNO055::getEvent(sensors_event_t *event)
{
 80a0588:	b570      	push	{r4, r5, r6, lr}
 80a058a:	460c      	mov	r4, r1
 80a058c:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
 80a058e:	2624      	movs	r6, #36	; 0x24
/*!
    @brief  Reads the sensor and returns the data as a sensors_event_t
*/
/**************************************************************************/
bool Adafruit_BNO055::getEvent(sensors_event_t *event)
{
 80a0590:	b086      	sub	sp, #24
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
 80a0592:	4632      	mov	r2, r6
 80a0594:	4608      	mov	r0, r1
 80a0596:	2100      	movs	r1, #0
 80a0598:	f001 fde7 	bl	80a216a <memset>

  event->version   = sizeof(sensors_event_t);
 80a059c:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
 80a059e:	68ab      	ldr	r3, [r5, #8]
 80a05a0:	6063      	str	r3, [r4, #4]
  event->type      = SENSOR_TYPE_ORIENTATION;
 80a05a2:	2303      	movs	r3, #3
 80a05a4:	60a3      	str	r3, [r4, #8]
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a05a6:	f000 f841 	bl	80a062c <HAL_Timer_Get_Milli_Seconds>
  event->timestamp = millis();

  /* Get a Euler angle sample for orientation */
  imu::Vector<3> euler = getVector(Adafruit_BNO055::VECTOR_EULER);
 80a05aa:	221a      	movs	r2, #26
  memset(event, 0, sizeof(sensors_event_t));

  event->version   = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
  event->type      = SENSOR_TYPE_ORIENTATION;
  event->timestamp = millis();
 80a05ac:	6120      	str	r0, [r4, #16]

  /* Get a Euler angle sample for orientation */
  imu::Vector<3> euler = getVector(Adafruit_BNO055::VECTOR_EULER);
 80a05ae:	4629      	mov	r1, r5
 80a05b0:	4668      	mov	r0, sp
 80a05b2:	f7ff ff61 	bl	80a0478 <_ZN15Adafruit_BNO0559getVectorENS_22adafruit_vector_type_tE>
  event->orientation.x = euler.x();
 80a05b6:	e9dd 0100 	ldrd	r0, r1, [sp]
 80a05ba:	f001 fd6d 	bl	80a2098 <__aeabi_d2f>
 80a05be:	6160      	str	r0, [r4, #20]
  event->orientation.y = euler.y();
 80a05c0:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 80a05c4:	f001 fd68 	bl	80a2098 <__aeabi_d2f>
 80a05c8:	61a0      	str	r0, [r4, #24]
  event->orientation.z = euler.z();
 80a05ca:	e9dd 0104 	ldrd	r0, r1, [sp, #16]
 80a05ce:	f001 fd63 	bl	80a2098 <__aeabi_d2f>
 80a05d2:	61e0      	str	r0, [r4, #28]

  return true;
}
 80a05d4:	2001      	movs	r0, #1
 80a05d6:	b006      	add	sp, #24
 80a05d8:	bd70      	pop	{r4, r5, r6, pc}
	...

080a05dc <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh>:
      buffer[i] = Wire.read();
  }

  /* ToDo: Check for errors! */
  return true;
}
 80a05dc:	b508      	push	{r3, lr}
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a05de:	4b09      	ldr	r3, [pc, #36]	; (80a0604 <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x28>)
 80a05e0:	2200      	movs	r2, #0
 80a05e2:	4909      	ldr	r1, [pc, #36]	; (80a0608 <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x2c>)
 80a05e4:	701a      	strb	r2, [r3, #0]
 80a05e6:	2301      	movs	r3, #1
 80a05e8:	700b      	strb	r3, [r1, #0]
 80a05ea:	4908      	ldr	r1, [pc, #32]	; (80a060c <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x30>)
 80a05ec:	700a      	strb	r2, [r1, #0]
 80a05ee:	4a08      	ldr	r2, [pc, #32]	; (80a0610 <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x34>)
 80a05f0:	7013      	strb	r3, [r2, #0]
 80a05f2:	4b08      	ldr	r3, [pc, #32]	; (80a0614 <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x38>)
 80a05f4:	2202      	movs	r2, #2
 80a05f6:	701a      	strb	r2, [r3, #0]
 80a05f8:	f000 f820 	bl	80a063c <HAL_Pin_Map>
 80a05fc:	4b06      	ldr	r3, [pc, #24]	; (80a0618 <_GLOBAL__sub_I__ZN15Adafruit_BNO055C2Elh+0x3c>)
 80a05fe:	6018      	str	r0, [r3, #0]
 80a0600:	bd08      	pop	{r3, pc}
 80a0602:	bf00      	nop
 80a0604:	20000333 	.word	0x20000333
 80a0608:	20000338 	.word	0x20000338
 80a060c:	20000331 	.word	0x20000331
 80a0610:	20000332 	.word	0x20000332
 80a0614:	20000330 	.word	0x20000330
 80a0618:	20000334 	.word	0x20000334

080a061c <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a061c:	b508      	push	{r3, lr}
 80a061e:	4b02      	ldr	r3, [pc, #8]	; (80a0628 <HAL_RNG_GetRandomNumber+0xc>)
 80a0620:	681b      	ldr	r3, [r3, #0]
 80a0622:	685b      	ldr	r3, [r3, #4]
 80a0624:	9301      	str	r3, [sp, #4]
 80a0626:	bd08      	pop	{r3, pc}
 80a0628:	0806019c 	.word	0x0806019c

080a062c <HAL_Timer_Get_Milli_Seconds>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a062c:	b508      	push	{r3, lr}
 80a062e:	4b02      	ldr	r3, [pc, #8]	; (80a0638 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a0630:	681b      	ldr	r3, [r3, #0]
 80a0632:	695b      	ldr	r3, [r3, #20]
 80a0634:	9301      	str	r3, [sp, #4]
 80a0636:	bd08      	pop	{r3, pc}
 80a0638:	0806019c 	.word	0x0806019c

080a063c <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a063c:	b508      	push	{r3, lr}
 80a063e:	4b02      	ldr	r3, [pc, #8]	; (80a0648 <HAL_Pin_Map+0xc>)
 80a0640:	681b      	ldr	r3, [r3, #0]
 80a0642:	681b      	ldr	r3, [r3, #0]
 80a0644:	9301      	str	r3, [sp, #4]
 80a0646:	bd08      	pop	{r3, pc}
 80a0648:	080601b0 	.word	0x080601b0

080a064c <HAL_I2C_Begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
 80a064c:	b508      	push	{r3, lr}
 80a064e:	4b02      	ldr	r3, [pc, #8]	; (80a0658 <HAL_I2C_Begin+0xc>)
 80a0650:	681b      	ldr	r3, [r3, #0]
 80a0652:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a0654:	9301      	str	r3, [sp, #4]
 80a0656:	bd08      	pop	{r3, pc}
 80a0658:	080601ac 	.word	0x080601ac

080a065c <HAL_I2C_Request_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
 80a065c:	b508      	push	{r3, lr}
 80a065e:	4b02      	ldr	r3, [pc, #8]	; (80a0668 <HAL_I2C_Request_Data+0xc>)
 80a0660:	681b      	ldr	r3, [r3, #0]
 80a0662:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a0664:	9301      	str	r3, [sp, #4]
 80a0666:	bd08      	pop	{r3, pc}
 80a0668:	080601ac 	.word	0x080601ac

080a066c <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
 80a066c:	b508      	push	{r3, lr}
 80a066e:	4b02      	ldr	r3, [pc, #8]	; (80a0678 <HAL_I2C_Begin_Transmission+0xc>)
 80a0670:	681b      	ldr	r3, [r3, #0]
 80a0672:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a0674:	9301      	str	r3, [sp, #4]
 80a0676:	bd08      	pop	{r3, pc}
 80a0678:	080601ac 	.word	0x080601ac

080a067c <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a067c:	b508      	push	{r3, lr}
 80a067e:	4b02      	ldr	r3, [pc, #8]	; (80a0688 <HAL_I2C_End_Transmission+0xc>)
 80a0680:	681b      	ldr	r3, [r3, #0]
 80a0682:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a0684:	9301      	str	r3, [sp, #4]
 80a0686:	bd08      	pop	{r3, pc}
 80a0688:	080601ac 	.word	0x080601ac

080a068c <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a068c:	b508      	push	{r3, lr}
 80a068e:	4b02      	ldr	r3, [pc, #8]	; (80a0698 <HAL_I2C_Write_Data+0xc>)
 80a0690:	681b      	ldr	r3, [r3, #0]
 80a0692:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a0694:	9301      	str	r3, [sp, #4]
 80a0696:	bd08      	pop	{r3, pc}
 80a0698:	080601ac 	.word	0x080601ac

080a069c <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a069c:	b508      	push	{r3, lr}
 80a069e:	4b02      	ldr	r3, [pc, #8]	; (80a06a8 <HAL_I2C_Available_Data+0xc>)
 80a06a0:	681b      	ldr	r3, [r3, #0]
 80a06a2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a06a4:	9301      	str	r3, [sp, #4]
 80a06a6:	bd08      	pop	{r3, pc}
 80a06a8:	080601ac 	.word	0x080601ac

080a06ac <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a06ac:	b508      	push	{r3, lr}
 80a06ae:	4b02      	ldr	r3, [pc, #8]	; (80a06b8 <HAL_I2C_Read_Data+0xc>)
 80a06b0:	681b      	ldr	r3, [r3, #0]
 80a06b2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a06b4:	9301      	str	r3, [sp, #4]
 80a06b6:	bd08      	pop	{r3, pc}
 80a06b8:	080601ac 	.word	0x080601ac

080a06bc <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a06bc:	b508      	push	{r3, lr}
 80a06be:	4b02      	ldr	r3, [pc, #8]	; (80a06c8 <HAL_I2C_Peek_Data+0xc>)
 80a06c0:	681b      	ldr	r3, [r3, #0]
 80a06c2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a06c4:	9301      	str	r3, [sp, #4]
 80a06c6:	bd08      	pop	{r3, pc}
 80a06c8:	080601ac 	.word	0x080601ac

080a06cc <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a06cc:	b508      	push	{r3, lr}
 80a06ce:	4b02      	ldr	r3, [pc, #8]	; (80a06d8 <HAL_I2C_Flush_Data+0xc>)
 80a06d0:	681b      	ldr	r3, [r3, #0]
 80a06d2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a06d4:	9301      	str	r3, [sp, #4]
 80a06d6:	bd08      	pop	{r3, pc}
 80a06d8:	080601ac 	.word	0x080601ac

080a06dc <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a06dc:	b508      	push	{r3, lr}
 80a06de:	4b03      	ldr	r3, [pc, #12]	; (80a06ec <HAL_I2C_Init+0x10>)
 80a06e0:	681b      	ldr	r3, [r3, #0]
 80a06e2:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a06e6:	9301      	str	r3, [sp, #4]
 80a06e8:	bd08      	pop	{r3, pc}
 80a06ea:	0000      	.short	0x0000
 80a06ec:	080601ac 	.word	0x080601ac

080a06f0 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a06f0:	b508      	push	{r3, lr}
 80a06f2:	4b02      	ldr	r3, [pc, #8]	; (80a06fc <HAL_SPI_Init+0xc>)
 80a06f4:	681b      	ldr	r3, [r3, #0]
 80a06f6:	69db      	ldr	r3, [r3, #28]
 80a06f8:	9301      	str	r3, [sp, #4]
 80a06fa:	bd08      	pop	{r3, pc}
 80a06fc:	080601b4 	.word	0x080601b4

080a0700 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a0700:	b508      	push	{r3, lr}
 80a0702:	4b02      	ldr	r3, [pc, #8]	; (80a070c <HAL_USART_Init+0xc>)
 80a0704:	681b      	ldr	r3, [r3, #0]
 80a0706:	699b      	ldr	r3, [r3, #24]
 80a0708:	9301      	str	r3, [sp, #4]
 80a070a:	bd08      	pop	{r3, pc}
 80a070c:	080601c4 	.word	0x080601c4

080a0710 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a0710:	b508      	push	{r3, lr}
 80a0712:	4b02      	ldr	r3, [pc, #8]	; (80a071c <HAL_USART_Write_Data+0xc>)
 80a0714:	681b      	ldr	r3, [r3, #0]
 80a0716:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a0718:	9301      	str	r3, [sp, #4]
 80a071a:	bd08      	pop	{r3, pc}
 80a071c:	080601c4 	.word	0x080601c4

080a0720 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a0720:	b508      	push	{r3, lr}
 80a0722:	4b02      	ldr	r3, [pc, #8]	; (80a072c <HAL_USART_Available_Data+0xc>)
 80a0724:	681b      	ldr	r3, [r3, #0]
 80a0726:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a0728:	9301      	str	r3, [sp, #4]
 80a072a:	bd08      	pop	{r3, pc}
 80a072c:	080601c4 	.word	0x080601c4

080a0730 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a0730:	b508      	push	{r3, lr}
 80a0732:	4b02      	ldr	r3, [pc, #8]	; (80a073c <HAL_USART_Read_Data+0xc>)
 80a0734:	681b      	ldr	r3, [r3, #0]
 80a0736:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0738:	9301      	str	r3, [sp, #4]
 80a073a:	bd08      	pop	{r3, pc}
 80a073c:	080601c4 	.word	0x080601c4

080a0740 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a0740:	b508      	push	{r3, lr}
 80a0742:	4b02      	ldr	r3, [pc, #8]	; (80a074c <HAL_USART_Peek_Data+0xc>)
 80a0744:	681b      	ldr	r3, [r3, #0]
 80a0746:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a0748:	9301      	str	r3, [sp, #4]
 80a074a:	bd08      	pop	{r3, pc}
 80a074c:	080601c4 	.word	0x080601c4

080a0750 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a0750:	b508      	push	{r3, lr}
 80a0752:	4b02      	ldr	r3, [pc, #8]	; (80a075c <HAL_USART_Flush_Data+0xc>)
 80a0754:	681b      	ldr	r3, [r3, #0]
 80a0756:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a0758:	9301      	str	r3, [sp, #4]
 80a075a:	bd08      	pop	{r3, pc}
 80a075c:	080601c4 	.word	0x080601c4

080a0760 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a0760:	b508      	push	{r3, lr}
 80a0762:	4b02      	ldr	r3, [pc, #8]	; (80a076c <HAL_USART_Available_Data_For_Write+0xc>)
 80a0764:	681b      	ldr	r3, [r3, #0]
 80a0766:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a0768:	9301      	str	r3, [sp, #4]
 80a076a:	bd08      	pop	{r3, pc}
 80a076c:	080601c4 	.word	0x080601c4

080a0770 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a0770:	b508      	push	{r3, lr}
 80a0772:	4b02      	ldr	r3, [pc, #8]	; (80a077c <HAL_USB_USART_Init+0xc>)
 80a0774:	681b      	ldr	r3, [r3, #0]
 80a0776:	681b      	ldr	r3, [r3, #0]
 80a0778:	9301      	str	r3, [sp, #4]
 80a077a:	bd08      	pop	{r3, pc}
 80a077c:	080601d8 	.word	0x080601d8

080a0780 <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a0780:	b508      	push	{r3, lr}
 80a0782:	4b02      	ldr	r3, [pc, #8]	; (80a078c <HAL_USB_USART_Begin+0xc>)
 80a0784:	681b      	ldr	r3, [r3, #0]
 80a0786:	685b      	ldr	r3, [r3, #4]
 80a0788:	9301      	str	r3, [sp, #4]
 80a078a:	bd08      	pop	{r3, pc}
 80a078c:	080601d8 	.word	0x080601d8

080a0790 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a0790:	b508      	push	{r3, lr}
 80a0792:	4b02      	ldr	r3, [pc, #8]	; (80a079c <HAL_USB_USART_Available_Data+0xc>)
 80a0794:	681b      	ldr	r3, [r3, #0]
 80a0796:	691b      	ldr	r3, [r3, #16]
 80a0798:	9301      	str	r3, [sp, #4]
 80a079a:	bd08      	pop	{r3, pc}
 80a079c:	080601d8 	.word	0x080601d8

080a07a0 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a07a0:	b508      	push	{r3, lr}
 80a07a2:	4b02      	ldr	r3, [pc, #8]	; (80a07ac <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a07a4:	681b      	ldr	r3, [r3, #0]
 80a07a6:	695b      	ldr	r3, [r3, #20]
 80a07a8:	9301      	str	r3, [sp, #4]
 80a07aa:	bd08      	pop	{r3, pc}
 80a07ac:	080601d8 	.word	0x080601d8

080a07b0 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a07b0:	b508      	push	{r3, lr}
 80a07b2:	4b02      	ldr	r3, [pc, #8]	; (80a07bc <HAL_USB_USART_Receive_Data+0xc>)
 80a07b4:	681b      	ldr	r3, [r3, #0]
 80a07b6:	699b      	ldr	r3, [r3, #24]
 80a07b8:	9301      	str	r3, [sp, #4]
 80a07ba:	bd08      	pop	{r3, pc}
 80a07bc:	080601d8 	.word	0x080601d8

080a07c0 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a07c0:	b508      	push	{r3, lr}
 80a07c2:	4b02      	ldr	r3, [pc, #8]	; (80a07cc <HAL_USB_USART_Send_Data+0xc>)
 80a07c4:	681b      	ldr	r3, [r3, #0]
 80a07c6:	69db      	ldr	r3, [r3, #28]
 80a07c8:	9301      	str	r3, [sp, #4]
 80a07ca:	bd08      	pop	{r3, pc}
 80a07cc:	080601d8 	.word	0x080601d8

080a07d0 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a07d0:	b508      	push	{r3, lr}
 80a07d2:	4b02      	ldr	r3, [pc, #8]	; (80a07dc <HAL_USB_USART_Flush_Data+0xc>)
 80a07d4:	681b      	ldr	r3, [r3, #0]
 80a07d6:	6a1b      	ldr	r3, [r3, #32]
 80a07d8:	9301      	str	r3, [sp, #4]
 80a07da:	bd08      	pop	{r3, pc}
 80a07dc:	080601d8 	.word	0x080601d8

080a07e0 <HAL_USB_HID_Init>:
#else
#define BASE_IDX 0
#endif

#ifdef USB_HID_ENABLE
DYNALIB_FN(BASE_IDX + 0, hal_usb, HAL_USB_HID_Init, void(uint8_t, void*))
 80a07e0:	b508      	push	{r3, lr}
 80a07e2:	4b02      	ldr	r3, [pc, #8]	; (80a07ec <HAL_USB_HID_Init+0xc>)
 80a07e4:	681b      	ldr	r3, [r3, #0]
 80a07e6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a07e8:	9301      	str	r3, [sp, #4]
 80a07ea:	bd08      	pop	{r3, pc}
 80a07ec:	080601d8 	.word	0x080601d8

080a07f0 <HAL_USB_HID_Send_Report>:
DYNALIB_FN(BASE_IDX + 1, hal_usb, HAL_USB_HID_Begin, void(uint8_t, void*))
DYNALIB_FN(BASE_IDX + 2, hal_usb, HAL_USB_HID_Send_Report, void(uint8_t, void*, uint16_t, void*))
 80a07f0:	b508      	push	{r3, lr}
 80a07f2:	4b02      	ldr	r3, [pc, #8]	; (80a07fc <HAL_USB_HID_Send_Report+0xc>)
 80a07f4:	681b      	ldr	r3, [r3, #0]
 80a07f6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a07f8:	9301      	str	r3, [sp, #4]
 80a07fa:	bd08      	pop	{r3, pc}
 80a07fc:	080601d8 	.word	0x080601d8

080a0800 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a0800:	b508      	push	{r3, lr}
 80a0802:	4b02      	ldr	r3, [pc, #8]	; (80a080c <set_system_mode+0xc>)
 80a0804:	681b      	ldr	r3, [r3, #0]
 80a0806:	685b      	ldr	r3, [r3, #4]
 80a0808:	9301      	str	r3, [sp, #4]
 80a080a:	bd08      	pop	{r3, pc}
 80a080c:	080601a4 	.word	0x080601a4

080a0810 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a0810:	b508      	push	{r3, lr}
 80a0812:	4b02      	ldr	r3, [pc, #8]	; (80a081c <system_delay_ms+0xc>)
 80a0814:	681b      	ldr	r3, [r3, #0]
 80a0816:	695b      	ldr	r3, [r3, #20]
 80a0818:	9301      	str	r3, [sp, #4]
 80a081a:	bd08      	pop	{r3, pc}
 80a081c:	080601a4 	.word	0x080601a4

080a0820 <system_thread_set_state>:
DYNALIB_FN(6, system, system_sleep, void(Spark_Sleep_TypeDef, long, uint32_t, void*))
DYNALIB_FN(7, system, system_sleep_pin, void(uint16_t, uint16_t, long, uint32_t, void*))
DYNALIB_FN(8, system, system_subscribe_event, int(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(9, system, system_unsubscribe_event, void(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(10, system, system_button_pushed_duration, uint16_t(uint8_t, void*))
DYNALIB_FN(11, system, system_thread_set_state, void(spark::feature::State, void*))
 80a0820:	b508      	push	{r3, lr}
 80a0822:	4b02      	ldr	r3, [pc, #8]	; (80a082c <system_thread_set_state+0xc>)
 80a0824:	681b      	ldr	r3, [r3, #0]
 80a0826:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a0828:	9301      	str	r3, [sp, #4]
 80a082a:	bd08      	pop	{r3, pc}
 80a082c:	080601a4 	.word	0x080601a4

080a0830 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a0830:	b508      	push	{r3, lr}
 80a0832:	4b02      	ldr	r3, [pc, #8]	; (80a083c <network_ready+0xc>)
 80a0834:	681b      	ldr	r3, [r3, #0]
 80a0836:	691b      	ldr	r3, [r3, #16]
 80a0838:	9301      	str	r3, [sp, #4]
 80a083a:	bd08      	pop	{r3, pc}
 80a083c:	080601c8 	.word	0x080601c8

080a0840 <free>:
#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
DYNALIB_FN(1, rt, free, void(void*))
 80a0840:	b508      	push	{r3, lr}
 80a0842:	4b02      	ldr	r3, [pc, #8]	; (80a084c <free+0xc>)
 80a0844:	681b      	ldr	r3, [r3, #0]
 80a0846:	685b      	ldr	r3, [r3, #4]
 80a0848:	9301      	str	r3, [sp, #4]
 80a084a:	bd08      	pop	{r3, pc}
 80a084c:	080601a0 	.word	0x080601a0

080a0850 <delay>:
  return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a0850:	2100      	movs	r1, #0
 80a0852:	f7ff bfdd 	b.w	80a0810 <system_delay_ms>
	...

080a0858 <_GLOBAL__sub_I_setADCSampleTime>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0858:	4b06      	ldr	r3, [pc, #24]	; (80a0874 <_GLOBAL__sub_I_setADCSampleTime+0x1c>)
 80a085a:	2200      	movs	r2, #0
 80a085c:	4906      	ldr	r1, [pc, #24]	; (80a0878 <_GLOBAL__sub_I_setADCSampleTime+0x20>)
 80a085e:	701a      	strb	r2, [r3, #0]
 80a0860:	2301      	movs	r3, #1
 80a0862:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a0864:	4905      	ldr	r1, [pc, #20]	; (80a087c <_GLOBAL__sub_I_setADCSampleTime+0x24>)
 80a0866:	700a      	strb	r2, [r1, #0]
 80a0868:	4a05      	ldr	r2, [pc, #20]	; (80a0880 <_GLOBAL__sub_I_setADCSampleTime+0x28>)
 80a086a:	7013      	strb	r3, [r2, #0]
 80a086c:	4b05      	ldr	r3, [pc, #20]	; (80a0884 <_GLOBAL__sub_I_setADCSampleTime+0x2c>)
 80a086e:	2202      	movs	r2, #2
 80a0870:	701a      	strb	r2, [r3, #0]
 80a0872:	4770      	bx	lr
 80a0874:	2000033c 	.word	0x2000033c
 80a0878:	2000033d 	.word	0x2000033d
 80a087c:	2000033a 	.word	0x2000033a
 80a0880:	2000033b 	.word	0x2000033b
 80a0884:	20000339 	.word	0x20000339

080a0888 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt>:
 80a0888:	4b06      	ldr	r3, [pc, #24]	; (80a08a4 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x1c>)
 80a088a:	2200      	movs	r2, #0
 80a088c:	4906      	ldr	r1, [pc, #24]	; (80a08a8 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x20>)
 80a088e:	701a      	strb	r2, [r3, #0]
 80a0890:	2301      	movs	r3, #1
 80a0892:	700b      	strb	r3, [r1, #0]
 80a0894:	4905      	ldr	r1, [pc, #20]	; (80a08ac <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x24>)
 80a0896:	700a      	strb	r2, [r1, #0]
 80a0898:	4a05      	ldr	r2, [pc, #20]	; (80a08b0 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x28>)
 80a089a:	7013      	strb	r3, [r2, #0]
 80a089c:	4b05      	ldr	r3, [pc, #20]	; (80a08b4 <_GLOBAL__sub_I__ZN10CANChannelC2E15HAL_CAN_Channeltt+0x2c>)
 80a089e:	2202      	movs	r2, #2
 80a08a0:	701a      	strb	r2, [r3, #0]
 80a08a2:	4770      	bx	lr
 80a08a4:	20000341 	.word	0x20000341
 80a08a8:	20000342 	.word	0x20000342
 80a08ac:	2000033f 	.word	0x2000033f
 80a08b0:	20000340 	.word	0x20000340
 80a08b4:	2000033e 	.word	0x2000033e

080a08b8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_>:
 80a08b8:	4b06      	ldr	r3, [pc, #24]	; (80a08d4 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x1c>)
 80a08ba:	2200      	movs	r2, #0
 80a08bc:	4906      	ldr	r1, [pc, #24]	; (80a08d8 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x20>)
 80a08be:	701a      	strb	r2, [r3, #0]
 80a08c0:	2301      	movs	r3, #1
 80a08c2:	700b      	strb	r3, [r1, #0]
 80a08c4:	4905      	ldr	r1, [pc, #20]	; (80a08dc <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x24>)
 80a08c6:	700a      	strb	r2, [r1, #0]
 80a08c8:	4a05      	ldr	r2, [pc, #20]	; (80a08e0 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x28>)
 80a08ca:	7013      	strb	r3, [r2, #0]
 80a08cc:	4b05      	ldr	r3, [pc, #20]	; (80a08e4 <_GLOBAL__sub_I__ZN10CloudClass22call_raw_user_functionEPvPKcS0_+0x2c>)
 80a08ce:	2202      	movs	r2, #2
 80a08d0:	701a      	strb	r2, [r3, #0]
 80a08d2:	4770      	bx	lr
 80a08d4:	20000346 	.word	0x20000346
 80a08d8:	20000347 	.word	0x20000347
 80a08dc:	20000344 	.word	0x20000344
 80a08e0:	20000345 	.word	0x20000345
 80a08e4:	20000343 	.word	0x20000343

080a08e8 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev>:
 80a08e8:	4b06      	ldr	r3, [pc, #24]	; (80a0904 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x1c>)
 80a08ea:	2200      	movs	r2, #0
 80a08ec:	4906      	ldr	r1, [pc, #24]	; (80a0908 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x20>)
 80a08ee:	701a      	strb	r2, [r3, #0]
 80a08f0:	2301      	movs	r3, #1
 80a08f2:	700b      	strb	r3, [r1, #0]
 80a08f4:	4905      	ldr	r1, [pc, #20]	; (80a090c <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x24>)
 80a08f6:	700a      	strb	r2, [r1, #0]
 80a08f8:	4a05      	ldr	r2, [pc, #20]	; (80a0910 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x28>)
 80a08fa:	7013      	strb	r3, [r2, #0]
 80a08fc:	4b05      	ldr	r3, [pc, #20]	; (80a0914 <_GLOBAL__sub_I__ZN9FuelGaugeC2Ev+0x2c>)
 80a08fe:	2202      	movs	r2, #2
 80a0900:	701a      	strb	r2, [r3, #0]
 80a0902:	4770      	bx	lr
 80a0904:	2000034b 	.word	0x2000034b
 80a0908:	2000034c 	.word	0x2000034c
 80a090c:	20000349 	.word	0x20000349
 80a0910:	2000034a 	.word	0x2000034a
 80a0914:	20000348 	.word	0x20000348

080a0918 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a0918:	4770      	bx	lr

080a091a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a091a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a091c:	4606      	mov	r6, r0
 80a091e:	4615      	mov	r5, r2
 80a0920:	460c      	mov	r4, r1
 80a0922:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a0924:	42bc      	cmp	r4, r7
 80a0926:	d006      	beq.n	80a0936 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a0928:	6833      	ldr	r3, [r6, #0]
 80a092a:	4630      	mov	r0, r6
 80a092c:	689b      	ldr	r3, [r3, #8]
 80a092e:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a0932:	4798      	blx	r3
 80a0934:	e7f6      	b.n	80a0924 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a0936:	4628      	mov	r0, r5
 80a0938:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a093a <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a093a:	7c00      	ldrb	r0, [r0, #16]
 80a093c:	2200      	movs	r2, #0
 80a093e:	f7ff bea5 	b.w	80a068c <HAL_I2C_Write_Data>

080a0942 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a0942:	7c00      	ldrb	r0, [r0, #16]
 80a0944:	2100      	movs	r1, #0
 80a0946:	f7ff bea9 	b.w	80a069c <HAL_I2C_Available_Data>

080a094a <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a094a:	7c00      	ldrb	r0, [r0, #16]
 80a094c:	2100      	movs	r1, #0
 80a094e:	f7ff bead 	b.w	80a06ac <HAL_I2C_Read_Data>

080a0952 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a0952:	7c00      	ldrb	r0, [r0, #16]
 80a0954:	2100      	movs	r1, #0
 80a0956:	f7ff beb1 	b.w	80a06bc <HAL_I2C_Peek_Data>

080a095a <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a095a:	7c00      	ldrb	r0, [r0, #16]
 80a095c:	2100      	movs	r1, #0
 80a095e:	f7ff beb5 	b.w	80a06cc <HAL_I2C_Flush_Data>

080a0962 <_ZN7TwoWireD0Ev>:
 80a0962:	b510      	push	{r4, lr}
 80a0964:	4604      	mov	r4, r0
 80a0966:	f7ff fb98 	bl	80a009a <_ZdlPv>
 80a096a:	4620      	mov	r0, r4
 80a096c:	bd10      	pop	{r4, pc}
	...

080a0970 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a0970:	b510      	push	{r4, lr}
 80a0972:	4604      	mov	r4, r0
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a0974:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a0978:	6082      	str	r2, [r0, #8]
 80a097a:	4a05      	ldr	r2, [pc, #20]	; (80a0990 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a097c:	2300      	movs	r3, #0
 80a097e:	6043      	str	r3, [r0, #4]
 80a0980:	6002      	str	r2, [r0, #0]
{
  _i2c = i2c;
 80a0982:	7401      	strb	r1, [r0, #16]
  HAL_I2C_Init(_i2c, NULL);
 80a0984:	4608      	mov	r0, r1
 80a0986:	4619      	mov	r1, r3
 80a0988:	f7ff fea8 	bl	80a06dc <HAL_I2C_Init>

}
 80a098c:	4620      	mov	r0, r4
 80a098e:	bd10      	pop	{r4, pc}
 80a0990:	080a2258 	.word	0x080a2258

080a0994 <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a0994:	2100      	movs	r1, #0
 80a0996:	7c00      	ldrb	r0, [r0, #16]
 80a0998:	460a      	mov	r2, r1
 80a099a:	460b      	mov	r3, r1
 80a099c:	f7ff be56 	b.w	80a064c <HAL_I2C_Begin>

080a09a0 <_ZN7TwoWire11requestFromEhhh>:
{
	HAL_I2C_End(_i2c, NULL);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)
{
 80a09a0:	b513      	push	{r0, r1, r4, lr}
  uint8_t result = HAL_I2C_Request_Data(_i2c, address, quantity, sendStop, NULL);
 80a09a2:	2400      	movs	r4, #0
 80a09a4:	7c00      	ldrb	r0, [r0, #16]
 80a09a6:	9400      	str	r4, [sp, #0]
 80a09a8:	f7ff fe58 	bl	80a065c <HAL_I2C_Request_Data>
  return result;
}
 80a09ac:	b2c0      	uxtb	r0, r0
 80a09ae:	b002      	add	sp, #8
 80a09b0:	bd10      	pop	{r4, pc}

080a09b2 <_ZN7TwoWire11requestFromEhh>:

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
 80a09b2:	2301      	movs	r3, #1
 80a09b4:	f7ff bff4 	b.w	80a09a0 <_ZN7TwoWire11requestFromEhhh>

080a09b8 <_ZN7TwoWire17beginTransmissionEh>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a09b8:	7c00      	ldrb	r0, [r0, #16]
 80a09ba:	2200      	movs	r2, #0
 80a09bc:	f7ff be56 	b.w	80a066c <HAL_I2C_Begin_Transmission>

080a09c0 <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a09c0:	7c00      	ldrb	r0, [r0, #16]
 80a09c2:	2200      	movs	r2, #0
 80a09c4:	f7ff be5a 	b.w	80a067c <HAL_I2C_End_Transmission>

080a09c8 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a09c8:	2101      	movs	r1, #1
 80a09ca:	f7ff bff9 	b.w	80a09c0 <_ZN7TwoWire15endTransmissionEh>
	...

080a09d0 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE>:
 80a09d0:	4b06      	ldr	r3, [pc, #24]	; (80a09ec <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x1c>)
 80a09d2:	2200      	movs	r2, #0
 80a09d4:	4906      	ldr	r1, [pc, #24]	; (80a09f0 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x20>)
 80a09d6:	701a      	strb	r2, [r3, #0]
 80a09d8:	2301      	movs	r3, #1
 80a09da:	700b      	strb	r3, [r1, #0]
 80a09dc:	4905      	ldr	r1, [pc, #20]	; (80a09f4 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x24>)
 80a09de:	700a      	strb	r2, [r1, #0]
 80a09e0:	4a05      	ldr	r2, [pc, #20]	; (80a09f8 <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x28>)
 80a09e2:	7013      	strb	r3, [r2, #0]
 80a09e4:	4b05      	ldr	r3, [pc, #20]	; (80a09fc <_GLOBAL__sub_I__Z16allocate_handlertRSt8functionIFvvEE+0x2c>)
 80a09e6:	2202      	movs	r2, #2
 80a09e8:	701a      	strb	r2, [r3, #0]
 80a09ea:	4770      	bx	lr
 80a09ec:	20000350 	.word	0x20000350
 80a09f0:	20000351 	.word	0x20000351
 80a09f4:	2000034e 	.word	0x2000034e
 80a09f8:	2000034f 	.word	0x2000034f
 80a09fc:	2000034d 	.word	0x2000034d

080a0a00 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a0a00:	4770      	bx	lr

080a0a02 <_ZN9IPAddressD0Ev>:
 80a0a02:	b510      	push	{r4, lr}
 80a0a04:	4604      	mov	r4, r0
 80a0a06:	f7ff fb48 	bl	80a009a <_ZdlPv>
 80a0a0a:	4620      	mov	r0, r4
 80a0a0c:	bd10      	pop	{r4, pc}

080a0a0e <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a0a0e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0a10:	460f      	mov	r7, r1
 80a0a12:	f100 0608 	add.w	r6, r0, #8
 80a0a16:	1d05      	adds	r5, r0, #4
 80a0a18:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0a1a:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a0a1e:	4638      	mov	r0, r7
 80a0a20:	220a      	movs	r2, #10
 80a0a22:	f000 f8da 	bl	80a0bda <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0a26:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a0a28:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a0a2a:	d007      	beq.n	80a0a3c <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a0a2c:	2c00      	cmp	r4, #0
 80a0a2e:	d0f4      	beq.n	80a0a1a <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a0a30:	4638      	mov	r0, r7
 80a0a32:	212e      	movs	r1, #46	; 0x2e
 80a0a34:	f000 f86a 	bl	80a0b0c <_ZN5Print5printEc>
 80a0a38:	4404      	add	r4, r0
 80a0a3a:	e7ee      	b.n	80a0a1a <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a0a3c:	4620      	mov	r0, r4
 80a0a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0a40 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a0a40:	b510      	push	{r4, lr}
 80a0a42:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a0a46:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a0a4a:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a0a4e:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a0a52:	2304      	movs	r3, #4
 80a0a54:	6041      	str	r1, [r0, #4]
 80a0a56:	7503      	strb	r3, [r0, #20]
 80a0a58:	bd10      	pop	{r4, pc}
	...

080a0a5c <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a0a5c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0a5e:	4604      	mov	r4, r0
 80a0a60:	4d04      	ldr	r5, [pc, #16]	; (80a0a74 <_ZN9IPAddressC1Ehhhh+0x18>)
 80a0a62:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a0a64:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a0a68:	9500      	str	r5, [sp, #0]
 80a0a6a:	f7ff ffe9 	bl	80a0a40 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a0a6e:	4620      	mov	r0, r4
 80a0a70:	b003      	add	sp, #12
 80a0a72:	bd30      	pop	{r4, r5, pc}
 80a0a74:	080a2280 	.word	0x080a2280

080a0a78 <_GLOBAL__sub_I__ZN5spark3LogE>:
    write(str, strlen(str));
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a0a78:	4a01      	ldr	r2, [pc, #4]	; (80a0a80 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a0a7a:	4b02      	ldr	r3, [pc, #8]	; (80a0a84 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a0a7c:	601a      	str	r2, [r3, #0]
 80a0a7e:	4770      	bx	lr
 80a0a80:	080a22bf 	.word	0x080a22bf
 80a0a84:	20000354 	.word	0x20000354

080a0a88 <_GLOBAL__sub_I__ZN4PMICC2Ev>:
 80a0a88:	4b06      	ldr	r3, [pc, #24]	; (80a0aa4 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x1c>)
 80a0a8a:	2200      	movs	r2, #0
 80a0a8c:	4906      	ldr	r1, [pc, #24]	; (80a0aa8 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x20>)
 80a0a8e:	701a      	strb	r2, [r3, #0]
 80a0a90:	2301      	movs	r3, #1
 80a0a92:	700b      	strb	r3, [r1, #0]
 80a0a94:	4905      	ldr	r1, [pc, #20]	; (80a0aac <_GLOBAL__sub_I__ZN4PMICC2Ev+0x24>)
 80a0a96:	700a      	strb	r2, [r1, #0]
 80a0a98:	4a05      	ldr	r2, [pc, #20]	; (80a0ab0 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x28>)
 80a0a9a:	7013      	strb	r3, [r2, #0]
 80a0a9c:	4b05      	ldr	r3, [pc, #20]	; (80a0ab4 <_GLOBAL__sub_I__ZN4PMICC2Ev+0x2c>)
 80a0a9e:	2202      	movs	r2, #2
 80a0aa0:	701a      	strb	r2, [r3, #0]
 80a0aa2:	4770      	bx	lr
 80a0aa4:	2000035b 	.word	0x2000035b
 80a0aa8:	2000035c 	.word	0x2000035c
 80a0aac:	20000359 	.word	0x20000359
 80a0ab0:	2000035a 	.word	0x2000035a
 80a0ab4:	20000358 	.word	0x20000358

080a0ab8 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a0ab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a0aba:	4606      	mov	r6, r0
 80a0abc:	460d      	mov	r5, r1
 80a0abe:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a0ac0:	2400      	movs	r4, #0
  while (size--) {
 80a0ac2:	42bd      	cmp	r5, r7
 80a0ac4:	d00c      	beq.n	80a0ae0 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a0ac6:	6833      	ldr	r3, [r6, #0]
 80a0ac8:	4630      	mov	r0, r6
 80a0aca:	689b      	ldr	r3, [r3, #8]
 80a0acc:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a0ad0:	4798      	blx	r3
     if (chunk>=0)
 80a0ad2:	2800      	cmp	r0, #0
 80a0ad4:	db01      	blt.n	80a0ada <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a0ad6:	4404      	add	r4, r0
 80a0ad8:	e7f3      	b.n	80a0ac2 <_ZN5Print5writeEPKhj+0xa>
/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     int chunk = write(*buffer++);
 80a0ada:	2c00      	cmp	r4, #0
 80a0adc:	bf08      	it	eq
 80a0ade:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a0ae0:	4620      	mov	r0, r4
 80a0ae2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a0ae4 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a0ae4:	b570      	push	{r4, r5, r6, lr}
 80a0ae6:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a0ae8:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a0aea:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a0aec:	b149      	cbz	r1, 80a0b02 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a0aee:	f001 fb44 	bl	80a217a <strlen>
 80a0af2:	682b      	ldr	r3, [r5, #0]
 80a0af4:	4602      	mov	r2, r0
 80a0af6:	4621      	mov	r1, r4
 80a0af8:	4628      	mov	r0, r5
    }
 80a0afa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a0afe:	68db      	ldr	r3, [r3, #12]
 80a0b00:	4718      	bx	r3
    }
 80a0b02:	bd70      	pop	{r4, r5, r6, pc}

080a0b04 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a0b04:	b508      	push	{r3, lr}
  return write(str);
 80a0b06:	f7ff ffed 	bl	80a0ae4 <_ZN5Print5writeEPKc>
}
 80a0b0a:	bd08      	pop	{r3, pc}

080a0b0c <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a0b0c:	6803      	ldr	r3, [r0, #0]
 80a0b0e:	689b      	ldr	r3, [r3, #8]
 80a0b10:	4718      	bx	r3

080a0b12 <_ZN5Print7printlnEv>:
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a0b12:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a0b14:	210d      	movs	r1, #13
 {
   return x.printTo(*this);
 }

size_t Print::println(void)
{
 80a0b16:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a0b18:	f7ff fff8 	bl	80a0b0c <_ZN5Print5printEc>
  n += print('\n');
 80a0b1c:	210a      	movs	r1, #10
   return x.printTo(*this);
 }

size_t Print::println(void)
{
  size_t n = print('\r');
 80a0b1e:	4604      	mov	r4, r0
  n += print('\n');
 80a0b20:	4628      	mov	r0, r5
 80a0b22:	f7ff fff3 	bl	80a0b0c <_ZN5Print5printEc>
  return n;
}
 80a0b26:	4420      	add	r0, r4
 80a0b28:	bd38      	pop	{r3, r4, r5, pc}

080a0b2a <_ZN5Print7printlnEPKc>:

size_t Print::println(const char c[])
{
 80a0b2a:	b538      	push	{r3, r4, r5, lr}
 80a0b2c:	4605      	mov	r5, r0
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0b2e:	f7ff ffd9 	bl	80a0ae4 <_ZN5Print5writeEPKc>
 80a0b32:	4604      	mov	r4, r0
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
 80a0b34:	4628      	mov	r0, r5
 80a0b36:	f7ff ffec 	bl	80a0b12 <_ZN5Print7printlnEv>
  return n;
}
 80a0b3a:	4420      	add	r0, r4
 80a0b3c:	bd38      	pop	{r3, r4, r5, pc}

080a0b3e <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a0b3e:	2a01      	cmp	r2, #1
 80a0b40:	bf98      	it	ls
 80a0b42:	220a      	movls	r2, #10
   return n;
 }

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a0b44:	b530      	push	{r4, r5, lr}
 80a0b46:	460b      	mov	r3, r1
 80a0b48:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a0b4a:	2100      	movs	r1, #0
 80a0b4c:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a0b50:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a0b54:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a0b58:	fb05 3312 	mls	r3, r5, r2, r3
 80a0b5c:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a0b5e:	2b09      	cmp	r3, #9
 80a0b60:	bf94      	ite	ls
 80a0b62:	3330      	addls	r3, #48	; 0x30
 80a0b64:	3337      	addhi	r3, #55	; 0x37
 80a0b66:	b2db      	uxtb	r3, r3
 80a0b68:	4621      	mov	r1, r4
 80a0b6a:	f804 3901 	strb.w	r3, [r4], #-1
 80a0b6e:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a0b70:	2d00      	cmp	r5, #0
 80a0b72:	d1ef      	bne.n	80a0b54 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a0b74:	f7ff ffb6 	bl	80a0ae4 <_ZN5Print5writeEPKc>
}
 80a0b78:	b00b      	add	sp, #44	; 0x2c
 80a0b7a:	bd30      	pop	{r4, r5, pc}

080a0b7c <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
 80a0b7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a0b80:	4607      	mov	r7, r0
 80a0b82:	460e      	mov	r6, r1
  if (base == 0) {
 80a0b84:	4615      	mov	r5, r2
 80a0b86:	b92a      	cbnz	r2, 80a0b94 <_ZN5Print5printEli+0x18>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a0b88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
 80a0b8c:	6803      	ldr	r3, [r0, #0]
 80a0b8e:	b2c9      	uxtb	r1, r1
 80a0b90:	689b      	ldr	r3, [r3, #8]
 80a0b92:	4718      	bx	r3
  } else if (base == 10) {
 80a0b94:	2a0a      	cmp	r2, #10
 80a0b96:	d102      	bne.n	80a0b9e <_ZN5Print5printEli+0x22>
    if (n < 0) {
 80a0b98:	2900      	cmp	r1, #0
 80a0b9a:	da01      	bge.n	80a0ba0 <_ZN5Print5printEli+0x24>
 80a0b9c:	e004      	b.n	80a0ba8 <_ZN5Print5printEli+0x2c>
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a0b9e:	b2d2      	uxtb	r2, r2
  }
}
 80a0ba0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a0ba4:	f7ff bfcb 	b.w	80a0b3e <_ZN5Print11printNumberEmh>
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a0ba8:	212d      	movs	r1, #45	; 0x2d
 80a0baa:	f7ff ffaf 	bl	80a0b0c <_ZN5Print5printEc>
      n = -n;
      return printNumber(n, 10) + t;
 80a0bae:	4271      	negs	r1, r6
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a0bb0:	4604      	mov	r4, r0
      n = -n;
      return printNumber(n, 10) + t;
 80a0bb2:	462a      	mov	r2, r5
 80a0bb4:	4638      	mov	r0, r7
 80a0bb6:	f7ff ffc2 	bl	80a0b3e <_ZN5Print11printNumberEmh>
 80a0bba:	4420      	add	r0, r4
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a0bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a0bc0 <_ZN5Print5printEmi>:

size_t Print::print(unsigned long n, int base)
{
 80a0bc0:	b510      	push	{r4, lr}
  if (base == 0) return write(n);
 80a0bc2:	b92a      	cbnz	r2, 80a0bd0 <_ZN5Print5printEmi+0x10>
  else return printNumber(n, base);
}
 80a0bc4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a0bc8:	6803      	ldr	r3, [r0, #0]
 80a0bca:	b2c9      	uxtb	r1, r1
 80a0bcc:	689b      	ldr	r3, [r3, #8]
 80a0bce:	4718      	bx	r3
  else return printNumber(n, base);
 80a0bd0:	b2d2      	uxtb	r2, r2
}
 80a0bd2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0bd6:	f7ff bfb2 	b.w	80a0b3e <_ZN5Print11printNumberEmh>

080a0bda <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a0bda:	f7ff bff1 	b.w	80a0bc0 <_ZN5Print5printEmi>
	...

080a0be0 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a0be0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a0be4:	4619      	mov	r1, r3

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a0be6:	4606      	mov	r6, r0
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a0be8:	4610      	mov	r0, r2

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
 80a0bea:	4690      	mov	r8, r2
 80a0bec:	461f      	mov	r7, r3
 80a0bee:	f89d 5020 	ldrb.w	r5, [sp, #32]
  size_t n = 0;

  if (isnan(number)) return print("nan");
 80a0bf2:	f000 fd8b 	bl	80a170c <__fpclassifyd>
 80a0bf6:	b910      	cbnz	r0, 80a0bfe <_ZN5Print10printFloatEdh+0x1e>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0bf8:	4630      	mov	r0, r6
 80a0bfa:	4943      	ldr	r1, [pc, #268]	; (80a0d08 <_ZN5Print10printFloatEdh+0x128>)
 80a0bfc:	e007      	b.n	80a0c0e <_ZN5Print10printFloatEdh+0x2e>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
 80a0bfe:	4640      	mov	r0, r8
 80a0c00:	4639      	mov	r1, r7
 80a0c02:	f000 fd83 	bl	80a170c <__fpclassifyd>
 80a0c06:	2801      	cmp	r0, #1
 80a0c08:	d105      	bne.n	80a0c16 <_ZN5Print10printFloatEdh+0x36>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0c0a:	4630      	mov	r0, r6
 80a0c0c:	493f      	ldr	r1, [pc, #252]	; (80a0d0c <_ZN5Print10printFloatEdh+0x12c>)
 80a0c0e:	f7ff ff69 	bl	80a0ae4 <_ZN5Print5writeEPKc>
size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
 80a0c12:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
 80a0c16:	4640      	mov	r0, r8
 80a0c18:	4639      	mov	r1, r7
 80a0c1a:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a0c1e:	4b3c      	ldr	r3, [pc, #240]	; (80a0d10 <_ZN5Print10printFloatEdh+0x130>)
 80a0c20:	f001 f9e8 	bl	80a1ff4 <__aeabi_dcmpgt>
 80a0c24:	b110      	cbz	r0, 80a0c2c <_ZN5Print10printFloatEdh+0x4c>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0c26:	4630      	mov	r0, r6
 80a0c28:	493a      	ldr	r1, [pc, #232]	; (80a0d14 <_ZN5Print10printFloatEdh+0x134>)
 80a0c2a:	e7f0      	b.n	80a0c0e <_ZN5Print10printFloatEdh+0x2e>
  size_t n = 0;

  if (isnan(number)) return print("nan");
  if (isinf(number)) return print("inf");
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
 80a0c2c:	4640      	mov	r0, r8
 80a0c2e:	4639      	mov	r1, r7
 80a0c30:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 80a0c34:	4b38      	ldr	r3, [pc, #224]	; (80a0d18 <_ZN5Print10printFloatEdh+0x138>)
 80a0c36:	f001 f9bf 	bl	80a1fb8 <__aeabi_dcmplt>
 80a0c3a:	2800      	cmp	r0, #0
 80a0c3c:	d1f3      	bne.n	80a0c26 <_ZN5Print10printFloatEdh+0x46>

  // Handle negative numbers
  if (number < 0.0)
 80a0c3e:	4640      	mov	r0, r8
 80a0c40:	4639      	mov	r1, r7
 80a0c42:	2200      	movs	r2, #0
 80a0c44:	2300      	movs	r3, #0
 80a0c46:	f001 f9b7 	bl	80a1fb8 <__aeabi_dcmplt>
 80a0c4a:	b138      	cbz	r0, 80a0c5c <_ZN5Print10printFloatEdh+0x7c>
  {
     n += print('-');
 80a0c4c:	4630      	mov	r0, r6
 80a0c4e:	212d      	movs	r1, #45	; 0x2d
 80a0c50:	f7ff ff5c 	bl	80a0b0c <_ZN5Print5printEc>
     number = -number;
 80a0c54:	f107 4700 	add.w	r7, r7, #2147483648	; 0x80000000
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically

  // Handle negative numbers
  if (number < 0.0)
  {
     n += print('-');
 80a0c58:	4604      	mov	r4, r0
 80a0c5a:	e000      	b.n	80a0c5e <_ZN5Print10printFloatEdh+0x7e>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
 80a0c5c:	4604      	mov	r4, r0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
 80a0c5e:	4b2f      	ldr	r3, [pc, #188]	; (80a0d1c <_ZN5Print10printFloatEdh+0x13c>)
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits)
{
  size_t n = 0;
 80a0c60:	f04f 0900 	mov.w	r9, #0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
 80a0c64:	2200      	movs	r2, #0
  for (uint8_t i=0; i<digits; ++i)
 80a0c66:	fa5f f189 	uxtb.w	r1, r9
 80a0c6a:	42a9      	cmp	r1, r5
 80a0c6c:	d20a      	bcs.n	80a0c84 <_ZN5Print10printFloatEdh+0xa4>
    rounding /= 10.0;
 80a0c6e:	4610      	mov	r0, r2
 80a0c70:	4619      	mov	r1, r3
 80a0c72:	2200      	movs	r2, #0
 80a0c74:	4b2a      	ldr	r3, [pc, #168]	; (80a0d20 <_ZN5Print10printFloatEdh+0x140>)
 80a0c76:	f001 f857 	bl	80a1d28 <__aeabi_ddiv>
 80a0c7a:	f109 0901 	add.w	r9, r9, #1
 80a0c7e:	4602      	mov	r2, r0
 80a0c80:	460b      	mov	r3, r1
 80a0c82:	e7f0      	b.n	80a0c66 <_ZN5Print10printFloatEdh+0x86>

  number += rounding;
 80a0c84:	4640      	mov	r0, r8
 80a0c86:	4639      	mov	r1, r7
 80a0c88:	f000 fd72 	bl	80a1770 <__adddf3>
 80a0c8c:	4689      	mov	r9, r1
 80a0c8e:	4680      	mov	r8, r0

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
 80a0c90:	f001 f9e2 	bl	80a2058 <__aeabi_d2uiz>
 80a0c94:	4607      	mov	r7, r0
  double remainder = number - (double)int_part;
 80a0c96:	f000 fea7 	bl	80a19e8 <__aeabi_ui2d>
 80a0c9a:	4602      	mov	r2, r0
 80a0c9c:	460b      	mov	r3, r1
 80a0c9e:	4640      	mov	r0, r8
 80a0ca0:	4649      	mov	r1, r9
 80a0ca2:	f000 fd63 	bl	80a176c <__aeabi_dsub>
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0ca6:	220a      	movs	r2, #10

  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
 80a0ca8:	4680      	mov	r8, r0
 80a0caa:	4689      	mov	r9, r1
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a0cac:	4630      	mov	r0, r6
 80a0cae:	4639      	mov	r1, r7
 80a0cb0:	f7ff ff45 	bl	80a0b3e <_ZN5Print11printNumberEmh>
  number += rounding;

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
  double remainder = number - (double)int_part;
  n += print(int_part);
 80a0cb4:	4404      	add	r4, r0

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
 80a0cb6:	b125      	cbz	r5, 80a0cc2 <_ZN5Print10printFloatEdh+0xe2>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a0cb8:	4630      	mov	r0, r6
 80a0cba:	491a      	ldr	r1, [pc, #104]	; (80a0d24 <_ZN5Print10printFloatEdh+0x144>)
 80a0cbc:	f7ff ff12 	bl	80a0ae4 <_ZN5Print5writeEPKc>
  double remainder = number - (double)int_part;
  n += print(int_part);

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    n += print(".");
 80a0cc0:	4404      	add	r4, r0
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
 80a0cc2:	b1f5      	cbz	r5, 80a0d02 <_ZN5Print10printFloatEdh+0x122>
  {
    remainder *= 10.0;
 80a0cc4:	4b16      	ldr	r3, [pc, #88]	; (80a0d20 <_ZN5Print10printFloatEdh+0x140>)
 80a0cc6:	2200      	movs	r2, #0
 80a0cc8:	4640      	mov	r0, r8
 80a0cca:	4649      	mov	r1, r9
 80a0ccc:	f000 ff02 	bl	80a1ad4 <__aeabi_dmul>
 80a0cd0:	4689      	mov	r9, r1
 80a0cd2:	4680      	mov	r8, r0
    int toPrint = int(remainder);
 80a0cd4:	f001 f998 	bl	80a2008 <__aeabi_d2iz>
 80a0cd8:	4607      	mov	r7, r0
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
 80a0cda:	220a      	movs	r2, #10
 80a0cdc:	4639      	mov	r1, r7
 80a0cde:	4630      	mov	r0, r6
 80a0ce0:	f7ff ff4c 	bl	80a0b7c <_ZN5Print5printEli>
  // Extract digits from the remainder one at a time
  while (digits-- > 0)
  {
    remainder *= 10.0;
    int toPrint = int(remainder);
    n += print(toPrint);
 80a0ce4:	4404      	add	r4, r0
    remainder -= toPrint;
 80a0ce6:	4638      	mov	r0, r7
 80a0ce8:	f000 fe8e 	bl	80a1a08 <__aeabi_i2d>
 80a0cec:	4602      	mov	r2, r0
 80a0cee:	460b      	mov	r3, r1
 80a0cf0:	4640      	mov	r0, r8
 80a0cf2:	4649      	mov	r1, r9
 80a0cf4:	f000 fd3a 	bl	80a176c <__aeabi_dsub>
 80a0cf8:	3d01      	subs	r5, #1
 80a0cfa:	4680      	mov	r8, r0
 80a0cfc:	4689      	mov	r9, r1
 80a0cfe:	b2ed      	uxtb	r5, r5
 80a0d00:	e7df      	b.n	80a0cc2 <_ZN5Print10printFloatEdh+0xe2>
  if (digits > 0) {
    n += print(".");
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
 80a0d02:	4620      	mov	r0, r4
    n += print(toPrint);
    remainder -= toPrint;
  }

  return n;
}
 80a0d04:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a0d08:	080a22c3 	.word	0x080a22c3
 80a0d0c:	080a22c7 	.word	0x080a22c7
 80a0d10:	41efffff 	.word	0x41efffff
 80a0d14:	080a22cb 	.word	0x080a22cb
 80a0d18:	c1efffff 	.word	0xc1efffff
 80a0d1c:	3fe00000 	.word	0x3fe00000
 80a0d20:	40240000 	.word	0x40240000
 80a0d24:	080a22cf 	.word	0x080a22cf

080a0d28 <_ZN5Print5printEdi>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
 80a0d28:	f89d 1000 	ldrb.w	r1, [sp]
 80a0d2c:	9100      	str	r1, [sp, #0]
 80a0d2e:	f7ff bf57 	b.w	80a0be0 <_ZN5Print10printFloatEdh>
	...

080a0d34 <_GLOBAL__sub_I__ZN5ServoC2Ev>:
 80a0d34:	4b06      	ldr	r3, [pc, #24]	; (80a0d50 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x1c>)
 80a0d36:	2200      	movs	r2, #0
 80a0d38:	4906      	ldr	r1, [pc, #24]	; (80a0d54 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x20>)
 80a0d3a:	701a      	strb	r2, [r3, #0]
 80a0d3c:	2301      	movs	r3, #1
 80a0d3e:	700b      	strb	r3, [r1, #0]
 80a0d40:	4905      	ldr	r1, [pc, #20]	; (80a0d58 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x24>)
 80a0d42:	700a      	strb	r2, [r1, #0]
 80a0d44:	4a05      	ldr	r2, [pc, #20]	; (80a0d5c <_GLOBAL__sub_I__ZN5ServoC2Ev+0x28>)
 80a0d46:	7013      	strb	r3, [r2, #0]
 80a0d48:	4b05      	ldr	r3, [pc, #20]	; (80a0d60 <_GLOBAL__sub_I__ZN5ServoC2Ev+0x2c>)
 80a0d4a:	2202      	movs	r2, #2
 80a0d4c:	701a      	strb	r2, [r3, #0]
 80a0d4e:	4770      	bx	lr
 80a0d50:	20000360 	.word	0x20000360
 80a0d54:	20000361 	.word	0x20000361
 80a0d58:	2000035e 	.word	0x2000035e
 80a0d5c:	2000035f 	.word	0x2000035f
 80a0d60:	2000035d 	.word	0x2000035d

080a0d64 <_ZN8SPIClassD1Ev>:
   */
  unsigned dividerReference;

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a0d64:	4770      	bx	lr

080a0d66 <_ZN8SPIClassD0Ev>:
 80a0d66:	b510      	push	{r4, lr}
 80a0d68:	4604      	mov	r4, r0
 80a0d6a:	f7ff f996 	bl	80a009a <_ZdlPv>
 80a0d6e:	4620      	mov	r0, r4
 80a0d70:	bd10      	pop	{r4, pc}
	...

080a0d74 <_ZN8SPIClassC1E17HAL_SPI_Interface>:

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0d74:	b510      	push	{r4, lr}
 80a0d76:	4604      	mov	r4, r0
 80a0d78:	4b04      	ldr	r3, [pc, #16]	; (80a0d8c <_ZN8SPIClassC1E17HAL_SPI_Interface+0x18>)
{
  _spi = spi;
 80a0d7a:	7101      	strb	r1, [r0, #4]

#include "spark_wiring_spi.h"
#include "core_hal.h"
#include "spark_macros.h"

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a0d7c:	6003      	str	r3, [r0, #0]
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a0d7e:	4608      	mov	r0, r1
 80a0d80:	f7ff fcb6 	bl	80a06f0 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a0d84:	2300      	movs	r3, #0
 80a0d86:	60a3      	str	r3, [r4, #8]
}
 80a0d88:	4620      	mov	r0, r4
 80a0d8a:	bd10      	pop	{r4, pc}
 80a0d8c:	080a22e0 	.word	0x080a22e0

080a0d90 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface>:
 80a0d90:	4b06      	ldr	r3, [pc, #24]	; (80a0dac <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x1c>)
 80a0d92:	2200      	movs	r2, #0
 80a0d94:	4906      	ldr	r1, [pc, #24]	; (80a0db0 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x20>)
 80a0d96:	701a      	strb	r2, [r3, #0]
 80a0d98:	2301      	movs	r3, #1
 80a0d9a:	700b      	strb	r3, [r1, #0]
 80a0d9c:	4905      	ldr	r1, [pc, #20]	; (80a0db4 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x24>)
 80a0d9e:	700a      	strb	r2, [r1, #0]
 80a0da0:	4a05      	ldr	r2, [pc, #20]	; (80a0db8 <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x28>)
 80a0da2:	7013      	strb	r3, [r2, #0]
 80a0da4:	4b05      	ldr	r3, [pc, #20]	; (80a0dbc <_GLOBAL__sub_I__ZN8SPIClassC2E17HAL_SPI_Interface+0x2c>)
 80a0da6:	2202      	movs	r2, #2
 80a0da8:	701a      	strb	r2, [r3, #0]
 80a0daa:	4770      	bx	lr
 80a0dac:	20000365 	.word	0x20000365
 80a0db0:	20000366 	.word	0x20000366
 80a0db4:	20000363 	.word	0x20000363
 80a0db8:	20000364 	.word	0x20000364
 80a0dbc:	20000362 	.word	0x20000362

080a0dc0 <_GLOBAL__sub_I__ZN6Stream9timedReadEv>:
 80a0dc0:	4b06      	ldr	r3, [pc, #24]	; (80a0ddc <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x1c>)
 80a0dc2:	2200      	movs	r2, #0
 80a0dc4:	4906      	ldr	r1, [pc, #24]	; (80a0de0 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x20>)
 80a0dc6:	701a      	strb	r2, [r3, #0]
 80a0dc8:	2301      	movs	r3, #1
 80a0dca:	700b      	strb	r3, [r1, #0]
 80a0dcc:	4905      	ldr	r1, [pc, #20]	; (80a0de4 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x24>)
 80a0dce:	700a      	strb	r2, [r1, #0]
 80a0dd0:	4a05      	ldr	r2, [pc, #20]	; (80a0de8 <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x28>)
 80a0dd2:	7013      	strb	r3, [r2, #0]
 80a0dd4:	4b05      	ldr	r3, [pc, #20]	; (80a0dec <_GLOBAL__sub_I__ZN6Stream9timedReadEv+0x2c>)
 80a0dd6:	2202      	movs	r2, #2
 80a0dd8:	701a      	strb	r2, [r3, #0]
 80a0dda:	4770      	bx	lr
 80a0ddc:	2000036a 	.word	0x2000036a
 80a0de0:	2000036b 	.word	0x2000036b
 80a0de4:	20000368 	.word	0x20000368
 80a0de8:	20000369 	.word	0x20000369
 80a0dec:	20000367 	.word	0x20000367

080a0df0 <_GLOBAL__sub_I_System>:
 80a0df0:	4b07      	ldr	r3, [pc, #28]	; (80a0e10 <_GLOBAL__sub_I_System+0x20>)
 80a0df2:	2000      	movs	r0, #0
 80a0df4:	4a07      	ldr	r2, [pc, #28]	; (80a0e14 <_GLOBAL__sub_I_System+0x24>)
 80a0df6:	7018      	strb	r0, [r3, #0]
 80a0df8:	2301      	movs	r3, #1
 80a0dfa:	7013      	strb	r3, [r2, #0]
 80a0dfc:	4a06      	ldr	r2, [pc, #24]	; (80a0e18 <_GLOBAL__sub_I_System+0x28>)
 80a0dfe:	7010      	strb	r0, [r2, #0]
 80a0e00:	4a06      	ldr	r2, [pc, #24]	; (80a0e1c <_GLOBAL__sub_I_System+0x2c>)
 80a0e02:	7013      	strb	r3, [r2, #0]
 80a0e04:	4b06      	ldr	r3, [pc, #24]	; (80a0e20 <_GLOBAL__sub_I_System+0x30>)
 80a0e06:	2202      	movs	r2, #2
 80a0e08:	701a      	strb	r2, [r3, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a0e0a:	f7ff bcf9 	b.w	80a0800 <set_system_mode>
 80a0e0e:	bf00      	nop
 80a0e10:	2000036f 	.word	0x2000036f
 80a0e14:	20000370 	.word	0x20000370
 80a0e18:	2000036d 	.word	0x2000036d
 80a0e1c:	2000036e 	.word	0x2000036e
 80a0e20:	2000036c 	.word	0x2000036c

080a0e24 <_GLOBAL__sub_I__ZN9TCPServerC2Etm>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a0e24:	4b06      	ldr	r3, [pc, #24]	; (80a0e40 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x1c>)
 80a0e26:	2200      	movs	r2, #0
 80a0e28:	4906      	ldr	r1, [pc, #24]	; (80a0e44 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x20>)
 80a0e2a:	701a      	strb	r2, [r3, #0]
 80a0e2c:	2301      	movs	r3, #1
 80a0e2e:	700b      	strb	r3, [r1, #0]
 80a0e30:	4905      	ldr	r1, [pc, #20]	; (80a0e48 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x24>)
 80a0e32:	700a      	strb	r2, [r1, #0]
 80a0e34:	4a05      	ldr	r2, [pc, #20]	; (80a0e4c <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x28>)
 80a0e36:	7013      	strb	r3, [r2, #0]
 80a0e38:	4b05      	ldr	r3, [pc, #20]	; (80a0e50 <_GLOBAL__sub_I__ZN9TCPServerC2Etm+0x2c>)
 80a0e3a:	2202      	movs	r2, #2
 80a0e3c:	701a      	strb	r2, [r3, #0]
 80a0e3e:	4770      	bx	lr
 80a0e40:	20000374 	.word	0x20000374
 80a0e44:	20000375 	.word	0x20000375
 80a0e48:	20000372 	.word	0x20000372
 80a0e4c:	20000373 	.word	0x20000373
 80a0e50:	20000371 	.word	0x20000371

080a0e54 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a0e54:	4b02      	ldr	r3, [pc, #8]	; (80a0e60 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a0e56:	681a      	ldr	r2, [r3, #0]
 80a0e58:	4b02      	ldr	r3, [pc, #8]	; (80a0e64 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a0e5a:	601a      	str	r2, [r3, #0]
 80a0e5c:	4770      	bx	lr
 80a0e5e:	bf00      	nop
 80a0e60:	20000300 	.word	0x20000300
 80a0e64:	20000378 	.word	0x20000378

080a0e68 <_GLOBAL__sub_I_tone>:
 80a0e68:	4b06      	ldr	r3, [pc, #24]	; (80a0e84 <_GLOBAL__sub_I_tone+0x1c>)
 80a0e6a:	2200      	movs	r2, #0
 80a0e6c:	4906      	ldr	r1, [pc, #24]	; (80a0e88 <_GLOBAL__sub_I_tone+0x20>)
 80a0e6e:	701a      	strb	r2, [r3, #0]
 80a0e70:	2301      	movs	r3, #1
 80a0e72:	700b      	strb	r3, [r1, #0]
 80a0e74:	4905      	ldr	r1, [pc, #20]	; (80a0e8c <_GLOBAL__sub_I_tone+0x24>)
 80a0e76:	700a      	strb	r2, [r1, #0]
 80a0e78:	4a05      	ldr	r2, [pc, #20]	; (80a0e90 <_GLOBAL__sub_I_tone+0x28>)
 80a0e7a:	7013      	strb	r3, [r2, #0]
 80a0e7c:	4b05      	ldr	r3, [pc, #20]	; (80a0e94 <_GLOBAL__sub_I_tone+0x2c>)
 80a0e7e:	2202      	movs	r2, #2
 80a0e80:	701a      	strb	r2, [r3, #0]
 80a0e82:	4770      	bx	lr
 80a0e84:	2000037f 	.word	0x2000037f
 80a0e88:	20000380 	.word	0x20000380
 80a0e8c:	2000037d 	.word	0x2000037d
 80a0e90:	2000037e 	.word	0x2000037e
 80a0e94:	2000037c 	.word	0x2000037c

080a0e98 <_GLOBAL__sub_I__ZN3UDPC2Ev>:
 80a0e98:	4b06      	ldr	r3, [pc, #24]	; (80a0eb4 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x1c>)
 80a0e9a:	2200      	movs	r2, #0
 80a0e9c:	4906      	ldr	r1, [pc, #24]	; (80a0eb8 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x20>)
 80a0e9e:	701a      	strb	r2, [r3, #0]
 80a0ea0:	2301      	movs	r3, #1
 80a0ea2:	700b      	strb	r3, [r1, #0]
 80a0ea4:	4905      	ldr	r1, [pc, #20]	; (80a0ebc <_GLOBAL__sub_I__ZN3UDPC2Ev+0x24>)
 80a0ea6:	700a      	strb	r2, [r1, #0]
 80a0ea8:	4a05      	ldr	r2, [pc, #20]	; (80a0ec0 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x28>)
 80a0eaa:	7013      	strb	r3, [r2, #0]
 80a0eac:	4b05      	ldr	r3, [pc, #20]	; (80a0ec4 <_GLOBAL__sub_I__ZN3UDPC2Ev+0x2c>)
 80a0eae:	2202      	movs	r2, #2
 80a0eb0:	701a      	strb	r2, [r3, #0]
 80a0eb2:	4770      	bx	lr
 80a0eb4:	20000384 	.word	0x20000384
 80a0eb8:	20000385 	.word	0x20000385
 80a0ebc:	20000382 	.word	0x20000382
 80a0ec0:	20000383 	.word	0x20000383
 80a0ec4:	20000381 	.word	0x20000381

080a0ec8 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a0ec8:	4770      	bx	lr

080a0eca <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a0eca:	7441      	strb	r1, [r0, #17]
 80a0ecc:	4770      	bx	lr

080a0ece <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a0ece:	7c00      	ldrb	r0, [r0, #16]
 80a0ed0:	f7ff bc46 	b.w	80a0760 <HAL_USART_Available_Data_For_Write>

080a0ed4 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a0ed4:	7c00      	ldrb	r0, [r0, #16]
 80a0ed6:	f7ff bc23 	b.w	80a0720 <HAL_USART_Available_Data>

080a0eda <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a0eda:	7c00      	ldrb	r0, [r0, #16]
 80a0edc:	f7ff bc30 	b.w	80a0740 <HAL_USART_Peek_Data>

080a0ee0 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a0ee0:	7c00      	ldrb	r0, [r0, #16]
 80a0ee2:	f7ff bc25 	b.w	80a0730 <HAL_USART_Read_Data>

080a0ee6 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a0ee6:	7c00      	ldrb	r0, [r0, #16]
 80a0ee8:	f7ff bc32 	b.w	80a0750 <HAL_USART_Flush_Data>

080a0eec <_ZN11USARTSerialD0Ev>:
 80a0eec:	b510      	push	{r4, lr}
 80a0eee:	4604      	mov	r4, r0
 80a0ef0:	f7ff f8d3 	bl	80a009a <_ZdlPv>
 80a0ef4:	4620      	mov	r0, r4
 80a0ef6:	bd10      	pop	{r4, pc}

080a0ef8 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a0ef8:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0efa:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a0efc:	4604      	mov	r4, r0
 80a0efe:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a0f00:	b925      	cbnz	r5, 80a0f0c <_ZN11USARTSerial5writeEh+0x14>
 80a0f02:	7c00      	ldrb	r0, [r0, #16]
 80a0f04:	f7ff fc2c 	bl	80a0760 <HAL_USART_Available_Data_For_Write>
 80a0f08:	2800      	cmp	r0, #0
 80a0f0a:	dd05      	ble.n	80a0f18 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0f0c:	7c20      	ldrb	r0, [r4, #16]
 80a0f0e:	4631      	mov	r1, r6
  }
  return 0;
}
 80a0f10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a0f14:	f7ff bbfc 	b.w	80a0710 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a0f18:	4628      	mov	r0, r5
 80a0f1a:	bd70      	pop	{r4, r5, r6, pc}

080a0f1c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0f1c:	b510      	push	{r4, lr}
 80a0f1e:	4604      	mov	r4, r0
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a0f20:	2000      	movs	r0, #0
 80a0f22:	6060      	str	r0, [r4, #4]
 80a0f24:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80a0f28:	60a0      	str	r0, [r4, #8]
 80a0f2a:	4806      	ldr	r0, [pc, #24]	; (80a0f44 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a0f2c:	7421      	strb	r1, [r4, #16]
#include "spark_wiring_usartserial.h"
#include "spark_wiring_constants.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a0f2e:	6020      	str	r0, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a0f30:	2001      	movs	r0, #1
 80a0f32:	7460      	strb	r0, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a0f34:	4608      	mov	r0, r1
 80a0f36:	4611      	mov	r1, r2
 80a0f38:	461a      	mov	r2, r3
 80a0f3a:	f7ff fbe1 	bl	80a0700 <HAL_USART_Init>
}
 80a0f3e:	4620      	mov	r0, r4
 80a0f40:	bd10      	pop	{r4, pc}
 80a0f42:	bf00      	nop
 80a0f44:	080a2320 	.word	0x080a2320

080a0f48 <_Z22__fetch_global_Serial1v>:
// Preinstantiate Objects //////////////////////////////////////////////////////
static Ring_Buffer serial1_rx_buffer;
static Ring_Buffer serial1_tx_buffer;

USARTSerial& __fetch_global_Serial1()
{
 80a0f48:	b538      	push	{r3, r4, r5, lr}
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a0f4a:	4d0c      	ldr	r5, [pc, #48]	; (80a0f7c <_Z22__fetch_global_Serial1v+0x34>)
 80a0f4c:	6829      	ldr	r1, [r5, #0]
 80a0f4e:	f011 0401 	ands.w	r4, r1, #1
 80a0f52:	d111      	bne.n	80a0f78 <_Z22__fetch_global_Serial1v+0x30>
 80a0f54:	4628      	mov	r0, r5
 80a0f56:	f7ff f8a2 	bl	80a009e <__cxa_guard_acquire>
 80a0f5a:	b168      	cbz	r0, 80a0f78 <_Z22__fetch_global_Serial1v+0x30>
 80a0f5c:	4621      	mov	r1, r4
 80a0f5e:	4a08      	ldr	r2, [pc, #32]	; (80a0f80 <_Z22__fetch_global_Serial1v+0x38>)
 80a0f60:	4b08      	ldr	r3, [pc, #32]	; (80a0f84 <_Z22__fetch_global_Serial1v+0x3c>)
 80a0f62:	4809      	ldr	r0, [pc, #36]	; (80a0f88 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f64:	f7ff ffda 	bl	80a0f1c <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a0f68:	4628      	mov	r0, r5
 80a0f6a:	f7ff f89d 	bl	80a00a8 <__cxa_guard_release>
 80a0f6e:	4806      	ldr	r0, [pc, #24]	; (80a0f88 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f70:	4906      	ldr	r1, [pc, #24]	; (80a0f8c <_Z22__fetch_global_Serial1v+0x44>)
 80a0f72:	4a07      	ldr	r2, [pc, #28]	; (80a0f90 <_Z22__fetch_global_Serial1v+0x48>)
 80a0f74:	f000 fb00 	bl	80a1578 <__aeabi_atexit>
	return serial1;
}
 80a0f78:	4803      	ldr	r0, [pc, #12]	; (80a0f88 <_Z22__fetch_global_Serial1v+0x40>)
 80a0f7a:	bd38      	pop	{r3, r4, r5, pc}
 80a0f7c:	20000420 	.word	0x20000420
 80a0f80:	20000424 	.word	0x20000424
 80a0f84:	2000039c 	.word	0x2000039c
 80a0f88:	20000388 	.word	0x20000388
 80a0f8c:	080a0ec9 	.word	0x080a0ec9
 80a0f90:	20000304 	.word	0x20000304

080a0f94 <_ZN11USBKeyboardD1Ev>:
	uint8_t modifiers;
	uint8_t reserved;
	uint8_t keys[6];
} KeyReport;

class USBKeyboard : public Print
 80a0f94:	4770      	bx	lr
	...

080a0f98 <_ZN11USBKeyboard7releaseEt>:
// sends the report.  This tells the OS the key is no longer pressed and that
// it shouldn't be repeated any more.
size_t USBKeyboard::release(uint16_t key)
{
	uint8_t i;
	if (key >= 136)
 80a0f98:	2987      	cmp	r1, #135	; 0x87

// release() takes the specified key out of the persistent key report and
// sends the report.  This tells the OS the key is no longer pressed and that
// it shouldn't be repeated any more.
size_t USBKeyboard::release(uint16_t key)
{
 80a0f9a:	b510      	push	{r4, lr}
 80a0f9c:	4603      	mov	r3, r0
	uint8_t i;
	if (key >= 136)
 80a0f9e:	d903      	bls.n	80a0fa8 <_ZN11USBKeyboard7releaseEt+0x10>
	{
		// it's a non-printing key (not a modifier)
		key = key - 136;
 80a0fa0:	f1a1 0088 	sub.w	r0, r1, #136	; 0x88
 80a0fa4:	b280      	uxth	r0, r0
 80a0fa6:	e016      	b.n	80a0fd6 <_ZN11USBKeyboard7releaseEt+0x3e>
	}
	else if (key >= 128)
 80a0fa8:	297f      	cmp	r1, #127	; 0x7f
 80a0faa:	d908      	bls.n	80a0fbe <_ZN11USBKeyboard7releaseEt+0x26>
	{
		// it's a modifier key
		keyReport.modifiers &= ~(1 << (key - 128));
 80a0fac:	3980      	subs	r1, #128	; 0x80
 80a0fae:	2201      	movs	r2, #1
 80a0fb0:	408a      	lsls	r2, r1
 80a0fb2:	7a41      	ldrb	r1, [r0, #9]
 80a0fb4:	ea21 0202 	bic.w	r2, r1, r2
 80a0fb8:	7242      	strb	r2, [r0, #9]
		key = 0;
 80a0fba:	2000      	movs	r0, #0
 80a0fbc:	e00b      	b.n	80a0fd6 <_ZN11USBKeyboard7releaseEt+0x3e>
	}
	else
	{
		// it's a printing key
		key = asciimap[key];
 80a0fbe:	4a11      	ldr	r2, [pc, #68]	; (80a1004 <_ZN11USBKeyboard7releaseEt+0x6c>)
 80a0fc0:	5c52      	ldrb	r2, [r2, r1]
 80a0fc2:	b290      	uxth	r0, r2
		if (!key)
 80a0fc4:	b1e0      	cbz	r0, 80a1000 <_ZN11USBKeyboard7releaseEt+0x68>
		{
			return 0;
		}
		if (key & 0x80)
 80a0fc6:	0611      	lsls	r1, r2, #24
		{
			// it's a capital letter or other character reached with shift
			keyReport.modifiers &= ~(0x02);	// the left shift modifier
 80a0fc8:	bf41      	itttt	mi
 80a0fca:	7a59      	ldrbmi	r1, [r3, #9]
			key &= 0x7F;
 80a0fcc:	f002 007f 	andmi.w	r0, r2, #127	; 0x7f
			return 0;
		}
		if (key & 0x80)
		{
			// it's a capital letter or other character reached with shift
			keyReport.modifiers &= ~(0x02);	// the left shift modifier
 80a0fd0:	f021 0102 	bicmi.w	r1, r1, #2
 80a0fd4:	7259      	strbmi	r1, [r3, #9]
 80a0fd6:	f103 020b 	add.w	r2, r3, #11
 80a0fda:	f103 0111 	add.w	r1, r3, #17

	// Test the key report to see if key is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i = 0 ; i < 6 ; i++)
	{
		if (0 != key && keyReport.keys[i] == key)
 80a0fde:	b120      	cbz	r0, 80a0fea <_ZN11USBKeyboard7releaseEt+0x52>
 80a0fe0:	7814      	ldrb	r4, [r2, #0]
 80a0fe2:	4284      	cmp	r4, r0
		{
			keyReport.keys[i] = 0x00;
 80a0fe4:	bf04      	itt	eq
 80a0fe6:	2400      	moveq	r4, #0
 80a0fe8:	7014      	strbeq	r4, [r2, #0]
 80a0fea:	3201      	adds	r2, #1
		}
	}

	// Test the key report to see if key is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i = 0 ; i < 6 ; i++)
 80a0fec:	428a      	cmp	r2, r1
 80a0fee:	d1f6      	bne.n	80a0fde <_ZN11USBKeyboard7releaseEt+0x46>
		{
			keyReport.keys[i] = 0x00;
		}
	}

	HAL_USB_HID_Send_Report(0, &keyReport, sizeof(keyReport), NULL);
 80a0ff0:	2000      	movs	r0, #0
 80a0ff2:	f103 0108 	add.w	r1, r3, #8
 80a0ff6:	2209      	movs	r2, #9
 80a0ff8:	4603      	mov	r3, r0
 80a0ffa:	f7ff fbf9 	bl	80a07f0 <HAL_USB_HID_Send_Report>
	return 1;
 80a0ffe:	2001      	movs	r0, #1
}
 80a1000:	bd10      	pop	{r4, pc}
 80a1002:	bf00      	nop
 80a1004:	080a2348 	.word	0x080a2348

080a1008 <_ZN11USBKeyboard10releaseAllEv>:

void USBKeyboard::releaseAll(void)
{
 80a1008:	4601      	mov	r1, r0
	keyReport.keys[0] = 0;
 80a100a:	2000      	movs	r0, #0
 80a100c:	72c8      	strb	r0, [r1, #11]
	keyReport.keys[1] = 0;
 80a100e:	7308      	strb	r0, [r1, #12]
	keyReport.keys[2] = 0;
 80a1010:	7348      	strb	r0, [r1, #13]
	keyReport.keys[3] = 0;
 80a1012:	7388      	strb	r0, [r1, #14]
	keyReport.keys[4] = 0;
 80a1014:	73c8      	strb	r0, [r1, #15]
	keyReport.keys[5] = 0;
 80a1016:	7408      	strb	r0, [r1, #16]
	keyReport.modifiers = 0;
 80a1018:	7248      	strb	r0, [r1, #9]
	HAL_USB_HID_Send_Report(0, &keyReport, sizeof(keyReport), NULL);
 80a101a:	2209      	movs	r2, #9
 80a101c:	3108      	adds	r1, #8
 80a101e:	4603      	mov	r3, r0
 80a1020:	f7ff bbe6 	b.w	80a07f0 <HAL_USB_HID_Send_Report>

080a1024 <_ZN11USBKeyboard5pressEt>:
// USB HID works, the host acts like the key remains pressed until we
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t USBKeyboard::press(uint16_t key)
{
	uint8_t i;
	if (key >= 136)
 80a1024:	2987      	cmp	r1, #135	; 0x87
// press() adds the specified key (printing, non-printing, or modifier)
// to the persistent key report and sends the report.  Because of the way
// USB HID works, the host acts like the key remains pressed until we
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t USBKeyboard::press(uint16_t key)
{
 80a1026:	b510      	push	{r4, lr}
 80a1028:	4603      	mov	r3, r0
	uint8_t i;
	if (key >= 136)
 80a102a:	d902      	bls.n	80a1032 <_ZN11USBKeyboard5pressEt+0xe>
	{
		// it's a non-printing key (not a modifier)
		key = key - 136;
 80a102c:	3988      	subs	r1, #136	; 0x88
 80a102e:	b289      	uxth	r1, r1
 80a1030:	e019      	b.n	80a1066 <_ZN11USBKeyboard5pressEt+0x42>
	}
	else if (key >= 128)
 80a1032:	297f      	cmp	r1, #127	; 0x7f
 80a1034:	d907      	bls.n	80a1046 <_ZN11USBKeyboard5pressEt+0x22>
	{
		// it's a modifier key
		keyReport.modifiers |= (1 << (key - 128));
 80a1036:	3980      	subs	r1, #128	; 0x80
 80a1038:	2201      	movs	r2, #1
 80a103a:	408a      	lsls	r2, r1
 80a103c:	7a41      	ldrb	r1, [r0, #9]
 80a103e:	430a      	orrs	r2, r1
 80a1040:	7242      	strb	r2, [r0, #9]
		key = 0;
 80a1042:	2100      	movs	r1, #0
 80a1044:	e00f      	b.n	80a1066 <_ZN11USBKeyboard5pressEt+0x42>
	}
	else
	{
		// it's a printing key
		key = asciimap[key];
 80a1046:	4a1c      	ldr	r2, [pc, #112]	; (80a10b8 <_ZN11USBKeyboard5pressEt+0x94>)
 80a1048:	5c52      	ldrb	r2, [r2, r1]
 80a104a:	b291      	uxth	r1, r2
		if (!key)
 80a104c:	b919      	cbnz	r1, 80a1056 <_ZN11USBKeyboard5pressEt+0x32>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 80a104e:	2201      	movs	r2, #1
 80a1050:	605a      	str	r2, [r3, #4]
		{
			setWriteError();
			return 0;
 80a1052:	2000      	movs	r0, #0
 80a1054:	bd10      	pop	{r4, pc}
		}
		if (key & 0x80)
 80a1056:	0610      	lsls	r0, r2, #24
		{
			// it's a capital letter or other character reached with shift
			keyReport.modifiers |= 0x02;	// the left shift modifier
 80a1058:	bf41      	itttt	mi
 80a105a:	7a59      	ldrbmi	r1, [r3, #9]
 80a105c:	f041 0102 	orrmi.w	r1, r1, #2
 80a1060:	7259      	strbmi	r1, [r3, #9]
			key &= 0x7F;
 80a1062:	f002 017f 	andmi.w	r1, r2, #127	; 0x7f
		}
	}

	// Add key to the keyReport only if it's not already present
	// and if there is an empty slot.
	if (keyReport.keys[0] != key && keyReport.keys[1] != key &&
 80a1066:	7ada      	ldrb	r2, [r3, #11]
 80a1068:	428a      	cmp	r2, r1
 80a106a:	d01b      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
 80a106c:	7b1a      	ldrb	r2, [r3, #12]
 80a106e:	428a      	cmp	r2, r1
 80a1070:	d018      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
 80a1072:	7b5a      	ldrb	r2, [r3, #13]
 80a1074:	428a      	cmp	r2, r1
 80a1076:	d015      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
		keyReport.keys[2] != key && keyReport.keys[3] != key &&
 80a1078:	7b9a      	ldrb	r2, [r3, #14]
 80a107a:	428a      	cmp	r2, r1
 80a107c:	d012      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
 80a107e:	7bda      	ldrb	r2, [r3, #15]
 80a1080:	428a      	cmp	r2, r1
 80a1082:	d00f      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
		keyReport.keys[4] != key && keyReport.keys[5] != key)
 80a1084:	7c1a      	ldrb	r2, [r3, #16]
 80a1086:	428a      	cmp	r2, r1
 80a1088:	d00c      	beq.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
 80a108a:	f103 000a 	add.w	r0, r3, #10
 80a108e:	2200      	movs	r2, #0
	{

		for (i=0; i<6; i++)
		{
			if (keyReport.keys[i] == 0x00)
 80a1090:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80a1094:	b914      	cbnz	r4, 80a109c <_ZN11USBKeyboard5pressEt+0x78>
			{
				keyReport.keys[i] = key;
 80a1096:	441a      	add	r2, r3
 80a1098:	72d1      	strb	r1, [r2, #11]
 80a109a:	e003      	b.n	80a10a4 <_ZN11USBKeyboard5pressEt+0x80>
 80a109c:	3201      	adds	r2, #1
	if (keyReport.keys[0] != key && keyReport.keys[1] != key &&
		keyReport.keys[2] != key && keyReport.keys[3] != key &&
		keyReport.keys[4] != key && keyReport.keys[5] != key)
	{

		for (i=0; i<6; i++)
 80a109e:	2a06      	cmp	r2, #6
 80a10a0:	d1f6      	bne.n	80a1090 <_ZN11USBKeyboard5pressEt+0x6c>
 80a10a2:	e7d4      	b.n	80a104e <_ZN11USBKeyboard5pressEt+0x2a>
			setWriteError();
			return 0;
		}
	}

	HAL_USB_HID_Send_Report(0, &keyReport, sizeof(keyReport), NULL);
 80a10a4:	2000      	movs	r0, #0
 80a10a6:	f103 0108 	add.w	r1, r3, #8
 80a10aa:	2209      	movs	r2, #9
 80a10ac:	4603      	mov	r3, r0
 80a10ae:	f7ff fb9f 	bl	80a07f0 <HAL_USB_HID_Send_Report>
	return 1;
 80a10b2:	2001      	movs	r0, #1
}
 80a10b4:	bd10      	pop	{r4, pc}
 80a10b6:	bf00      	nop
 80a10b8:	080a2348 	.word	0x080a2348

080a10bc <_ZN11USBKeyboard8writeRawEt>:
	keyReport.modifiers = 0;
	HAL_USB_HID_Send_Report(0, &keyReport, sizeof(keyReport), NULL);
}

size_t USBKeyboard::writeRaw(uint16_t key)
{
 80a10bc:	b570      	push	{r4, r5, r6, lr}
	uint8_t p = press(136 + key);	// Keydown
 80a10be:	3188      	adds	r1, #136	; 0x88
 80a10c0:	6803      	ldr	r3, [r0, #0]
 80a10c2:	b28c      	uxth	r4, r1
 80a10c4:	4621      	mov	r1, r4
 80a10c6:	695b      	ldr	r3, [r3, #20]
	keyReport.modifiers = 0;
	HAL_USB_HID_Send_Report(0, &keyReport, sizeof(keyReport), NULL);
}

size_t USBKeyboard::writeRaw(uint16_t key)
{
 80a10c8:	4605      	mov	r5, r0
	uint8_t p = press(136 + key);	// Keydown
 80a10ca:	4798      	blx	r3
 80a10cc:	4606      	mov	r6, r0
	delay(100);
 80a10ce:	2064      	movs	r0, #100	; 0x64
 80a10d0:	f7ff fbbe 	bl	80a0850 <delay>
	uint8_t r = release(136 + key);	// Keyup
 80a10d4:	682b      	ldr	r3, [r5, #0]
 80a10d6:	4628      	mov	r0, r5
 80a10d8:	699b      	ldr	r3, [r3, #24]
 80a10da:	4621      	mov	r1, r4
 80a10dc:	4798      	blx	r3
	(void)r;
	return (p);					// just return the result of press() since release() almost always returns 1
}
 80a10de:	b2f0      	uxtb	r0, r6
 80a10e0:	bd70      	pop	{r4, r5, r6, pc}

080a10e2 <_ZN11USBKeyboard5writeEh>:

size_t USBKeyboard::write(uint8_t key)
{
 80a10e2:	b570      	push	{r4, r5, r6, lr}
	uint8_t p = press(key);		// Keydown
 80a10e4:	6803      	ldr	r3, [r0, #0]
	(void)r;
	return (p);					// just return the result of press() since release() almost always returns 1
}

size_t USBKeyboard::write(uint8_t key)
{
 80a10e6:	4604      	mov	r4, r0
	uint8_t p = press(key);		// Keydown
 80a10e8:	695b      	ldr	r3, [r3, #20]
 80a10ea:	460d      	mov	r5, r1
 80a10ec:	4798      	blx	r3
 80a10ee:	4606      	mov	r6, r0
	delay(100);
 80a10f0:	2064      	movs	r0, #100	; 0x64
 80a10f2:	f7ff fbad 	bl	80a0850 <delay>
	uint8_t r = release(key);	// Keyup
 80a10f6:	6823      	ldr	r3, [r4, #0]
 80a10f8:	4620      	mov	r0, r4
 80a10fa:	699b      	ldr	r3, [r3, #24]
 80a10fc:	4629      	mov	r1, r5
 80a10fe:	4798      	blx	r3
	(void)r;
	return (p);					// just return the result of press() since release() almost always returns 1
}
 80a1100:	b2f0      	uxtb	r0, r6
 80a1102:	bd70      	pop	{r4, r5, r6, pc}

080a1104 <_ZN11USBKeyboardD0Ev>:
 80a1104:	b510      	push	{r4, lr}
 80a1106:	4604      	mov	r4, r0
 80a1108:	f7fe ffc7 	bl	80a009a <_ZdlPv>
 80a110c:	4620      	mov	r0, r4
 80a110e:	bd10      	pop	{r4, pc}

080a1110 <_ZN11USBKeyboardC1Ev>:
};

//
// Constructor
//
USBKeyboard::USBKeyboard(void)
 80a1110:	b510      	push	{r4, lr}
 80a1112:	4604      	mov	r4, r0
 80a1114:	4b05      	ldr	r3, [pc, #20]	; (80a112c <_ZN11USBKeyboardC1Ev+0x1c>)
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a1116:	2000      	movs	r0, #0
 80a1118:	6023      	str	r3, [r4, #0]
{
	keyReport.reportId = 0x02;
 80a111a:	2302      	movs	r3, #2
 80a111c:	6060      	str	r0, [r4, #4]
	HAL_USB_HID_Init(0, NULL);
 80a111e:	4601      	mov	r1, r0
//
// Constructor
//
USBKeyboard::USBKeyboard(void)
{
	keyReport.reportId = 0x02;
 80a1120:	7223      	strb	r3, [r4, #8]
	HAL_USB_HID_Init(0, NULL);
 80a1122:	f7ff fb5d 	bl	80a07e0 <HAL_USB_HID_Init>
}
 80a1126:	4620      	mov	r0, r4
 80a1128:	bd10      	pop	{r4, pc}
 80a112a:	bf00      	nop
 80a112c:	080a23d0 	.word	0x080a23d0

080a1130 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev>:
 80a1130:	4b0c      	ldr	r3, [pc, #48]	; (80a1164 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x34>)
 80a1132:	2200      	movs	r2, #0
 80a1134:	490c      	ldr	r1, [pc, #48]	; (80a1168 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x38>)
	(void)r;
	return (p);					// just return the result of press() since release() almost always returns 1
}

//Preinstantiate Object
USBKeyboard Keyboard;
 80a1136:	b510      	push	{r4, lr}
 80a1138:	701a      	strb	r2, [r3, #0]
 80a113a:	2301      	movs	r3, #1
 80a113c:	700b      	strb	r3, [r1, #0]
 80a113e:	490b      	ldr	r1, [pc, #44]	; (80a116c <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x3c>)
 80a1140:	4c0b      	ldr	r4, [pc, #44]	; (80a1170 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x40>)
 80a1142:	700a      	strb	r2, [r1, #0]
 80a1144:	4a0b      	ldr	r2, [pc, #44]	; (80a1174 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x44>)
 80a1146:	4620      	mov	r0, r4
 80a1148:	7013      	strb	r3, [r2, #0]
 80a114a:	4b0b      	ldr	r3, [pc, #44]	; (80a1178 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x48>)
 80a114c:	2202      	movs	r2, #2
 80a114e:	701a      	strb	r2, [r3, #0]
 80a1150:	f7ff ffde 	bl	80a1110 <_ZN11USBKeyboardC1Ev>
 80a1154:	4620      	mov	r0, r4
 80a1156:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a115a:	4908      	ldr	r1, [pc, #32]	; (80a117c <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x4c>)
 80a115c:	4a08      	ldr	r2, [pc, #32]	; (80a1180 <_GLOBAL__sub_I__ZN11USBKeyboardC2Ev+0x50>)
 80a115e:	f000 ba0b 	b.w	80a1578 <__aeabi_atexit>
 80a1162:	bf00      	nop
 80a1164:	200004c2 	.word	0x200004c2
 80a1168:	200004c3 	.word	0x200004c3
 80a116c:	200004c0 	.word	0x200004c0
 80a1170:	200004ac 	.word	0x200004ac
 80a1174:	200004c1 	.word	0x200004c1
 80a1178:	200004a8 	.word	0x200004a8
 80a117c:	080a0f95 	.word	0x080a0f95
 80a1180:	20000304 	.word	0x20000304

080a1184 <_ZN8USBMouseC1Ev>:
#include "spark_wiring_usbmouse.h"

//
// Constructor
//
USBMouse::USBMouse(void)
 80a1184:	b510      	push	{r4, lr}
 80a1186:	4604      	mov	r4, r0
{
    mouseReport.reportId = 0x01;
 80a1188:	2301      	movs	r3, #1
 80a118a:	7003      	strb	r3, [r0, #0]
    HAL_USB_HID_Init(0, NULL);
 80a118c:	2000      	movs	r0, #0
 80a118e:	4601      	mov	r1, r0
 80a1190:	f7ff fb26 	bl	80a07e0 <HAL_USB_HID_Init>
}
 80a1194:	4620      	mov	r0, r4
 80a1196:	bd10      	pop	{r4, pc}

080a1198 <_GLOBAL__sub_I__ZN8USBMouseC2Ev>:
 80a1198:	4b07      	ldr	r3, [pc, #28]	; (80a11b8 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x20>)
 80a119a:	2200      	movs	r2, #0
 80a119c:	4907      	ldr	r1, [pc, #28]	; (80a11bc <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x24>)
 80a119e:	701a      	strb	r2, [r3, #0]
 80a11a0:	2301      	movs	r3, #1
 80a11a2:	700b      	strb	r3, [r1, #0]
 80a11a4:	4906      	ldr	r1, [pc, #24]	; (80a11c0 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x28>)

	return false;
}

//Preinstantiate Object
USBMouse Mouse;
 80a11a6:	4807      	ldr	r0, [pc, #28]	; (80a11c4 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x2c>)
 80a11a8:	700a      	strb	r2, [r1, #0]
 80a11aa:	4a07      	ldr	r2, [pc, #28]	; (80a11c8 <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x30>)
 80a11ac:	7013      	strb	r3, [r2, #0]
 80a11ae:	4b07      	ldr	r3, [pc, #28]	; (80a11cc <_GLOBAL__sub_I__ZN8USBMouseC2Ev+0x34>)
 80a11b0:	2202      	movs	r2, #2
 80a11b2:	701a      	strb	r2, [r3, #0]
 80a11b4:	f7ff bfe6 	b.w	80a1184 <_ZN8USBMouseC1Ev>
 80a11b8:	200004cc 	.word	0x200004cc
 80a11bc:	200004cd 	.word	0x200004cd
 80a11c0:	200004ca 	.word	0x200004ca
 80a11c4:	200004c4 	.word	0x200004c4
 80a11c8:	200004cb 	.word	0x200004cb
 80a11cc:	200004c9 	.word	0x200004c9

080a11d0 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a11d0:	7441      	strb	r1, [r0, #17]
 80a11d2:	4770      	bx	lr

080a11d4 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a11d4:	4770      	bx	lr

080a11d6 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a11d6:	7c00      	ldrb	r0, [r0, #16]
 80a11d8:	2100      	movs	r1, #0
 80a11da:	f7ff bae9 	b.w	80a07b0 <HAL_USB_USART_Receive_Data>

080a11de <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a11de:	7c00      	ldrb	r0, [r0, #16]
 80a11e0:	2101      	movs	r1, #1
 80a11e2:	f7ff bae5 	b.w	80a07b0 <HAL_USB_USART_Receive_Data>

080a11e6 <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a11e6:	7c00      	ldrb	r0, [r0, #16]
 80a11e8:	f7ff bada 	b.w	80a07a0 <HAL_USB_USART_Available_Data_For_Write>

080a11ec <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a11ec:	7c00      	ldrb	r0, [r0, #16]
 80a11ee:	f7ff bacf 	b.w	80a0790 <HAL_USB_USART_Available_Data>

080a11f2 <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a11f2:	b538      	push	{r3, r4, r5, lr}
 80a11f4:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a11f6:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a11f8:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a11fa:	f7ff fad1 	bl	80a07a0 <HAL_USB_USART_Available_Data_For_Write>
 80a11fe:	2800      	cmp	r0, #0
 80a1200:	dc01      	bgt.n	80a1206 <_ZN9USBSerial5writeEh+0x14>
 80a1202:	7c60      	ldrb	r0, [r4, #17]
 80a1204:	b120      	cbz	r0, 80a1210 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a1206:	7c20      	ldrb	r0, [r4, #16]
 80a1208:	4629      	mov	r1, r5
 80a120a:	f7ff fad9 	bl	80a07c0 <HAL_USB_USART_Send_Data>
    return 1;
 80a120e:	2001      	movs	r0, #1
  }
  return 0;
}
 80a1210:	bd38      	pop	{r3, r4, r5, pc}

080a1212 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a1212:	7c00      	ldrb	r0, [r0, #16]
 80a1214:	f7ff badc 	b.w	80a07d0 <HAL_USB_USART_Flush_Data>

080a1218 <_ZN9USBSerialD0Ev>:
 80a1218:	b510      	push	{r4, lr}
 80a121a:	4604      	mov	r4, r0
 80a121c:	f7fe ff3d 	bl	80a009a <_ZdlPv>
 80a1220:	4620      	mov	r0, r4
 80a1222:	bd10      	pop	{r4, pc}

080a1224 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a1224:	b510      	push	{r4, lr}
 80a1226:	4604      	mov	r4, r0
 80a1228:	2300      	movs	r3, #0
 80a122a:	6043      	str	r3, [r0, #4]
 80a122c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a1230:	6083      	str	r3, [r0, #8]
 80a1232:	4b05      	ldr	r3, [pc, #20]	; (80a1248 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
{
  _serial = serial;
 80a1234:	7401      	strb	r1, [r0, #16]

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a1236:	6003      	str	r3, [r0, #0]
{
  _serial = serial;
  _blocking = true;
 80a1238:	2301      	movs	r3, #1
 80a123a:	7443      	strb	r3, [r0, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a123c:	4608      	mov	r0, r1
 80a123e:	4611      	mov	r1, r2
 80a1240:	f7ff fa96 	bl	80a0770 <HAL_USB_USART_Init>
}
 80a1244:	4620      	mov	r0, r4
 80a1246:	bd10      	pop	{r4, pc}
 80a1248:	080a23f8 	.word	0x080a23f8

080a124c <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a124c:	7c00      	ldrb	r0, [r0, #16]
 80a124e:	2200      	movs	r2, #0
 80a1250:	f7ff ba96 	b.w	80a0780 <HAL_USB_USART_Begin>

080a1254 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a1254:	b510      	push	{r4, lr}
 80a1256:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a1258:	2100      	movs	r1, #0
 80a125a:	2214      	movs	r2, #20
 80a125c:	f000 ff85 	bl	80a216a <memset>

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1260:	4b05      	ldr	r3, [pc, #20]	; (80a1278 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a1262:	4620      	mov	r0, r4

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a1264:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a1266:	4b05      	ldr	r3, [pc, #20]	; (80a127c <_Z19acquireSerialBufferv+0x28>)
 80a1268:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a126a:	f240 1301 	movw	r3, #257	; 0x101
 80a126e:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a1270:	2381      	movs	r3, #129	; 0x81
 80a1272:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a1274:	bd10      	pop	{r4, pc}
 80a1276:	bf00      	nop
 80a1278:	20000555 	.word	0x20000555
 80a127c:	200004d4 	.word	0x200004d4

080a1280 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a1280:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a1282:	4d0e      	ldr	r5, [pc, #56]	; (80a12bc <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a1284:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a1286:	a801      	add	r0, sp, #4
 80a1288:	f7ff ffe4 	bl	80a1254 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a128c:	6829      	ldr	r1, [r5, #0]
 80a128e:	f011 0401 	ands.w	r4, r1, #1
 80a1292:	d110      	bne.n	80a12b6 <_Z16_fetch_usbserialv+0x36>
 80a1294:	4628      	mov	r0, r5
 80a1296:	f7fe ff02 	bl	80a009e <__cxa_guard_acquire>
 80a129a:	b160      	cbz	r0, 80a12b6 <_Z16_fetch_usbserialv+0x36>
 80a129c:	4621      	mov	r1, r4
 80a129e:	aa01      	add	r2, sp, #4
 80a12a0:	4807      	ldr	r0, [pc, #28]	; (80a12c0 <_Z16_fetch_usbserialv+0x40>)
 80a12a2:	f7ff ffbf 	bl	80a1224 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a12a6:	4628      	mov	r0, r5
 80a12a8:	f7fe fefe 	bl	80a00a8 <__cxa_guard_release>
 80a12ac:	4804      	ldr	r0, [pc, #16]	; (80a12c0 <_Z16_fetch_usbserialv+0x40>)
 80a12ae:	4905      	ldr	r1, [pc, #20]	; (80a12c4 <_Z16_fetch_usbserialv+0x44>)
 80a12b0:	4a05      	ldr	r2, [pc, #20]	; (80a12c8 <_Z16_fetch_usbserialv+0x48>)
 80a12b2:	f000 f961 	bl	80a1578 <__aeabi_atexit>
	return _usbserial;
}
 80a12b6:	4802      	ldr	r0, [pc, #8]	; (80a12c0 <_Z16_fetch_usbserialv+0x40>)
 80a12b8:	b007      	add	sp, #28
 80a12ba:	bd30      	pop	{r4, r5, pc}
 80a12bc:	200004d0 	.word	0x200004d0
 80a12c0:	20000658 	.word	0x20000658
 80a12c4:	080a11d5 	.word	0x080a11d5
 80a12c8:	20000304 	.word	0x20000304

080a12cc <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a12cc:	b510      	push	{r4, lr}
 80a12ce:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a12d0:	2100      	movs	r1, #0
 80a12d2:	2214      	movs	r2, #20
 80a12d4:	f000 ff49 	bl	80a216a <memset>

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a12d8:	4b05      	ldr	r3, [pc, #20]	; (80a12f0 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a12da:	4620      	mov	r0, r4

#ifdef USB_SERIAL_USERSPACE_BUFFERS
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a12dc:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a12de:	4b05      	ldr	r3, [pc, #20]	; (80a12f4 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a12e0:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a12e2:	f240 1301 	movw	r3, #257	; 0x101
 80a12e6:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a12e8:	2381      	movs	r3, #129	; 0x81
 80a12ea:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a12ec:	bd10      	pop	{r4, pc}
 80a12ee:	bf00      	nop
 80a12f0:	20000708 	.word	0x20000708
 80a12f4:	20000670 	.word	0x20000670

080a12f8 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a12f8:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a12fa:	4c0e      	ldr	r4, [pc, #56]	; (80a1334 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a12fc:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a12fe:	a801      	add	r0, sp, #4
 80a1300:	f7ff ffe4 	bl	80a12cc <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a1304:	6823      	ldr	r3, [r4, #0]
 80a1306:	07db      	lsls	r3, r3, #31
 80a1308:	d410      	bmi.n	80a132c <_Z17_fetch_usbserial1v+0x34>
 80a130a:	4620      	mov	r0, r4
 80a130c:	f7fe fec7 	bl	80a009e <__cxa_guard_acquire>
 80a1310:	b160      	cbz	r0, 80a132c <_Z17_fetch_usbserial1v+0x34>
 80a1312:	2101      	movs	r1, #1
 80a1314:	aa01      	add	r2, sp, #4
 80a1316:	4808      	ldr	r0, [pc, #32]	; (80a1338 <_Z17_fetch_usbserial1v+0x40>)
 80a1318:	f7ff ff84 	bl	80a1224 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a131c:	4620      	mov	r0, r4
 80a131e:	f7fe fec3 	bl	80a00a8 <__cxa_guard_release>
 80a1322:	4805      	ldr	r0, [pc, #20]	; (80a1338 <_Z17_fetch_usbserial1v+0x40>)
 80a1324:	4905      	ldr	r1, [pc, #20]	; (80a133c <_Z17_fetch_usbserial1v+0x44>)
 80a1326:	4a06      	ldr	r2, [pc, #24]	; (80a1340 <_Z17_fetch_usbserial1v+0x48>)
 80a1328:	f000 f926 	bl	80a1578 <__aeabi_atexit>
  return _usbserial1;
}
 80a132c:	4802      	ldr	r0, [pc, #8]	; (80a1338 <_Z17_fetch_usbserial1v+0x40>)
 80a132e:	b006      	add	sp, #24
 80a1330:	bd10      	pop	{r4, pc}
 80a1332:	bf00      	nop
 80a1334:	2000066c 	.word	0x2000066c
 80a1338:	200006f4 	.word	0x200006f4
 80a133c:	080a11d5 	.word	0x080a11d5
 80a1340:	20000304 	.word	0x20000304

080a1344 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a1344:	4770      	bx	lr

080a1346 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a1346:	2000      	movs	r0, #0
 80a1348:	4601      	mov	r1, r0
 80a134a:	4602      	mov	r2, r0
 80a134c:	f7ff ba70 	b.w	80a0830 <network_ready>

080a1350 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a1350:	4803      	ldr	r0, [pc, #12]	; (80a1360 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x10>)
 80a1352:	4b04      	ldr	r3, [pc, #16]	; (80a1364 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a1354:	4904      	ldr	r1, [pc, #16]	; (80a1368 <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x18>)
 80a1356:	4a05      	ldr	r2, [pc, #20]	; (80a136c <_GLOBAL__sub_I__ZN5spark9WiFiClass4scanEP15WiFiAccessPointj+0x1c>)
 80a1358:	6003      	str	r3, [r0, #0]
 80a135a:	f000 b90d 	b.w	80a1578 <__aeabi_atexit>
 80a135e:	bf00      	nop
 80a1360:	2000080c 	.word	0x2000080c
 80a1364:	080a2428 	.word	0x080a2428
 80a1368:	080a1345 	.word	0x080a1345
 80a136c:	20000304 	.word	0x20000304

080a1370 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a1370:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a1372:	4b14      	ldr	r3, [pc, #80]	; (80a13c4 <serialEventRun+0x54>)
 80a1374:	b133      	cbz	r3, 80a1384 <serialEventRun+0x14>
 80a1376:	f7ff ff83 	bl	80a1280 <_Z16_fetch_usbserialv>
 80a137a:	6803      	ldr	r3, [r0, #0]
 80a137c:	691b      	ldr	r3, [r3, #16]
 80a137e:	4798      	blx	r3
 80a1380:	2800      	cmp	r0, #0
 80a1382:	dc16      	bgt.n	80a13b2 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a1384:	4b10      	ldr	r3, [pc, #64]	; (80a13c8 <serialEventRun+0x58>)
 80a1386:	b133      	cbz	r3, 80a1396 <serialEventRun+0x26>
 80a1388:	f7ff fdde 	bl	80a0f48 <_Z22__fetch_global_Serial1v>
 80a138c:	6803      	ldr	r3, [r0, #0]
 80a138e:	691b      	ldr	r3, [r3, #16]
 80a1390:	4798      	blx	r3
 80a1392:	2800      	cmp	r0, #0
 80a1394:	dc10      	bgt.n	80a13b8 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a1396:	4b0d      	ldr	r3, [pc, #52]	; (80a13cc <serialEventRun+0x5c>)
 80a1398:	b10b      	cbz	r3, 80a139e <serialEventRun+0x2e>
 80a139a:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a139e:	4b0c      	ldr	r3, [pc, #48]	; (80a13d0 <serialEventRun+0x60>)
 80a13a0:	b17b      	cbz	r3, 80a13c2 <serialEventRun+0x52>
 80a13a2:	f7ff ffa9 	bl	80a12f8 <_Z17_fetch_usbserial1v>
 80a13a6:	6803      	ldr	r3, [r0, #0]
 80a13a8:	691b      	ldr	r3, [r3, #16]
 80a13aa:	4798      	blx	r3
 80a13ac:	2800      	cmp	r0, #0
 80a13ae:	dc06      	bgt.n	80a13be <serialEventRun+0x4e>
 80a13b0:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a13b2:	f3af 8000 	nop.w
 80a13b6:	e7e5      	b.n	80a1384 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a13b8:	f3af 8000 	nop.w
 80a13bc:	e7eb      	b.n	80a1396 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a13be:	f3af 8000 	nop.w
 80a13c2:	bd08      	pop	{r3, pc}
	...

080a13d4 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a13d4:	b508      	push	{r3, lr}
	serialEventRun();
 80a13d6:	f7ff ffcb 	bl	80a1370 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a13da:	f7ff f927 	bl	80a062c <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a13de:	4b01      	ldr	r3, [pc, #4]	; (80a13e4 <_post_loop+0x10>)
 80a13e0:	6018      	str	r0, [r3, #0]
 80a13e2:	bd08      	pop	{r3, pc}
 80a13e4:	20000818 	.word	0x20000818

080a13e8 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a13e8:	4802      	ldr	r0, [pc, #8]	; (80a13f4 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a13ea:	4a03      	ldr	r2, [pc, #12]	; (80a13f8 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a13ec:	4903      	ldr	r1, [pc, #12]	; (80a13fc <_Z33system_initialize_user_backup_ramv+0x14>)
 80a13ee:	1a12      	subs	r2, r2, r0
 80a13f0:	f000 beb0 	b.w	80a2154 <memcpy>
 80a13f4:	40024000 	.word	0x40024000
 80a13f8:	40024004 	.word	0x40024004
 80a13fc:	080a24a0 	.word	0x080a24a0

080a1400 <module_user_init_hook>:

#endif


void module_user_init_hook()
{
 80a1400:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a1402:	4c09      	ldr	r4, [pc, #36]	; (80a1428 <module_user_init_hook+0x28>)
 80a1404:	4d09      	ldr	r5, [pc, #36]	; (80a142c <module_user_init_hook+0x2c>)
 80a1406:	6823      	ldr	r3, [r4, #0]
 80a1408:	1b5a      	subs	r2, r3, r5
 80a140a:	4253      	negs	r3, r2
 80a140c:	4153      	adcs	r3, r2
 80a140e:	4a08      	ldr	r2, [pc, #32]	; (80a1430 <module_user_init_hook+0x30>)
 80a1410:	7013      	strb	r3, [r2, #0]
    if (!backup_ram_was_valid_) {
 80a1412:	b913      	cbnz	r3, 80a141a <module_user_init_hook+0x1a>
        system_initialize_user_backup_ram();
 80a1414:	f7ff ffe8 	bl	80a13e8 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a1418:	6025      	str	r5, [r4, #0]
    /* for dynamically linked user part, set the random seed if the user
     * app defines random_seed_from_cloud.
     */
// todo - add a RNG define for that capability
#if defined(STM32F2XX)
    if (random_seed_from_cloud) {
 80a141a:	4b06      	ldr	r3, [pc, #24]	; (80a1434 <module_user_init_hook+0x34>)
 80a141c:	b11b      	cbz	r3, 80a1426 <module_user_init_hook+0x26>
    		uint32_t seed = HAL_RNG_GetRandomNumber();
 80a141e:	f7ff f8fd 	bl	80a061c <HAL_RNG_GetRandomNumber>
    		random_seed_from_cloud(seed);
 80a1422:	f3af 8000 	nop.w
 80a1426:	bd38      	pop	{r3, r4, r5, pc}
 80a1428:	40024000 	.word	0x40024000
 80a142c:	9a271c1e 	.word	0x9a271c1e
 80a1430:	20000810 	.word	0x20000810
 80a1434:	00000000 	.word	0x00000000

080a1438 <_GLOBAL__sub_I_pinMode>:
{
public:
    typedef uint8_t flag_t;
    inline SleepNetworkFlag(SystemSleepNetwork f) : SleepNetworkFlag(static_cast<flag_t>(f)) {}

    inline SleepNetworkFlag(flag_t flag) : flag_(flag) {}
 80a1438:	4b06      	ldr	r3, [pc, #24]	; (80a1454 <_GLOBAL__sub_I_pinMode+0x1c>)
 80a143a:	2200      	movs	r2, #0
 80a143c:	4906      	ldr	r1, [pc, #24]	; (80a1458 <_GLOBAL__sub_I_pinMode+0x20>)
 80a143e:	701a      	strb	r2, [r3, #0]
 80a1440:	2301      	movs	r3, #1
 80a1442:	700b      	strb	r3, [r1, #0]

class PublishFlag
{
public:
	typedef uint8_t flag_t;
	PublishFlag(flag_t flag) : flag_(flag) {}
 80a1444:	4905      	ldr	r1, [pc, #20]	; (80a145c <_GLOBAL__sub_I_pinMode+0x24>)
 80a1446:	700a      	strb	r2, [r1, #0]
 80a1448:	4a05      	ldr	r2, [pc, #20]	; (80a1460 <_GLOBAL__sub_I_pinMode+0x28>)
 80a144a:	7013      	strb	r3, [r2, #0]
 80a144c:	4b05      	ldr	r3, [pc, #20]	; (80a1464 <_GLOBAL__sub_I_pinMode+0x2c>)
 80a144e:	2202      	movs	r2, #2
 80a1450:	701a      	strb	r2, [r3, #0]
 80a1452:	4770      	bx	lr
 80a1454:	20000814 	.word	0x20000814
 80a1458:	20000815 	.word	0x20000815
 80a145c:	20000812 	.word	0x20000812
 80a1460:	20000813 	.word	0x20000813
 80a1464:	20000811 	.word	0x20000811

080a1468 <_GLOBAL__sub_I_Particle>:
 80a1468:	4b06      	ldr	r3, [pc, #24]	; (80a1484 <_GLOBAL__sub_I_Particle+0x1c>)
 80a146a:	2200      	movs	r2, #0
 80a146c:	4906      	ldr	r1, [pc, #24]	; (80a1488 <_GLOBAL__sub_I_Particle+0x20>)
 80a146e:	701a      	strb	r2, [r3, #0]
 80a1470:	2301      	movs	r3, #1
 80a1472:	700b      	strb	r3, [r1, #0]
 80a1474:	4905      	ldr	r1, [pc, #20]	; (80a148c <_GLOBAL__sub_I_Particle+0x24>)
 80a1476:	700a      	strb	r2, [r1, #0]
 80a1478:	4a05      	ldr	r2, [pc, #20]	; (80a1490 <_GLOBAL__sub_I_Particle+0x28>)
 80a147a:	7013      	strb	r3, [r2, #0]
 80a147c:	4b05      	ldr	r3, [pc, #20]	; (80a1494 <_GLOBAL__sub_I_Particle+0x2c>)
 80a147e:	2202      	movs	r2, #2
 80a1480:	701a      	strb	r2, [r3, #0]
 80a1482:	4770      	bx	lr
 80a1484:	2000081f 	.word	0x2000081f
 80a1488:	20000820 	.word	0x20000820
 80a148c:	2000081d 	.word	0x2000081d
 80a1490:	2000081e 	.word	0x2000081e
 80a1494:	2000081c 	.word	0x2000081c

080a1498 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a1498:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a149a:	4d0b      	ldr	r5, [pc, #44]	; (80a14c8 <_Z19__fetch_global_Wirev+0x30>)
 80a149c:	6829      	ldr	r1, [r5, #0]
 80a149e:	f011 0401 	ands.w	r4, r1, #1
 80a14a2:	d10f      	bne.n	80a14c4 <_Z19__fetch_global_Wirev+0x2c>
 80a14a4:	4628      	mov	r0, r5
 80a14a6:	f7fe fdfa 	bl	80a009e <__cxa_guard_acquire>
 80a14aa:	b158      	cbz	r0, 80a14c4 <_Z19__fetch_global_Wirev+0x2c>
 80a14ac:	4621      	mov	r1, r4
 80a14ae:	4807      	ldr	r0, [pc, #28]	; (80a14cc <_Z19__fetch_global_Wirev+0x34>)
 80a14b0:	f7ff fa5e 	bl	80a0970 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a14b4:	4628      	mov	r0, r5
 80a14b6:	f7fe fdf7 	bl	80a00a8 <__cxa_guard_release>
 80a14ba:	4804      	ldr	r0, [pc, #16]	; (80a14cc <_Z19__fetch_global_Wirev+0x34>)
 80a14bc:	4904      	ldr	r1, [pc, #16]	; (80a14d0 <_Z19__fetch_global_Wirev+0x38>)
 80a14be:	4a05      	ldr	r2, [pc, #20]	; (80a14d4 <_Z19__fetch_global_Wirev+0x3c>)
 80a14c0:	f000 f85a 	bl	80a1578 <__aeabi_atexit>
	return wire;
}
 80a14c4:	4801      	ldr	r0, [pc, #4]	; (80a14cc <_Z19__fetch_global_Wirev+0x34>)
 80a14c6:	bd38      	pop	{r3, r4, r5, pc}
 80a14c8:	20000824 	.word	0x20000824
 80a14cc:	20000828 	.word	0x20000828
 80a14d0:	080a0919 	.word	0x080a0919
 80a14d4:	20000304 	.word	0x20000304

080a14d8 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a14d8:	b513      	push	{r0, r1, r4, lr}
 80a14da:	4c08      	ldr	r4, [pc, #32]	; (80a14fc <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a14dc:	2100      	movs	r1, #0
 80a14de:	9100      	str	r1, [sp, #0]
 80a14e0:	460a      	mov	r2, r1
 80a14e2:	460b      	mov	r3, r1
 80a14e4:	4620      	mov	r0, r4
 80a14e6:	f7ff fab9 	bl	80a0a5c <_ZN9IPAddressC1Ehhhh>
 80a14ea:	4620      	mov	r0, r4
 80a14ec:	4904      	ldr	r1, [pc, #16]	; (80a1500 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a14ee:	4a05      	ldr	r2, [pc, #20]	; (80a1504 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a14f0:	b002      	add	sp, #8
 80a14f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a14f6:	f000 b83f 	b.w	80a1578 <__aeabi_atexit>
 80a14fa:	bf00      	nop
 80a14fc:	2000083c 	.word	0x2000083c
 80a1500:	080a0a01 	.word	0x080a0a01
 80a1504:	20000304 	.word	0x20000304

080a1508 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1508:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a150a:	4b12      	ldr	r3, [pc, #72]	; (80a1554 <_GLOBAL__sub_I_SPI+0x4c>)
 80a150c:	2100      	movs	r1, #0
 80a150e:	7019      	strb	r1, [r3, #0]
 80a1510:	4b11      	ldr	r3, [pc, #68]	; (80a1558 <_GLOBAL__sub_I_SPI+0x50>)
 80a1512:	2401      	movs	r4, #1
 80a1514:	701c      	strb	r4, [r3, #0]
 80a1516:	4b11      	ldr	r3, [pc, #68]	; (80a155c <_GLOBAL__sub_I_SPI+0x54>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1518:	4f11      	ldr	r7, [pc, #68]	; (80a1560 <_GLOBAL__sub_I_SPI+0x58>)
 80a151a:	7019      	strb	r1, [r3, #0]
 80a151c:	4b11      	ldr	r3, [pc, #68]	; (80a1564 <_GLOBAL__sub_I_SPI+0x5c>)
 80a151e:	2202      	movs	r2, #2
 80a1520:	701c      	strb	r4, [r3, #0]
 80a1522:	4b11      	ldr	r3, [pc, #68]	; (80a1568 <_GLOBAL__sub_I_SPI+0x60>)
 80a1524:	4e11      	ldr	r6, [pc, #68]	; (80a156c <_GLOBAL__sub_I_SPI+0x64>)
 80a1526:	4d12      	ldr	r5, [pc, #72]	; (80a1570 <_GLOBAL__sub_I_SPI+0x68>)
 80a1528:	4638      	mov	r0, r7
 80a152a:	701a      	strb	r2, [r3, #0]
 80a152c:	f7ff fc22 	bl	80a0d74 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1530:	4638      	mov	r0, r7

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a1532:	4f10      	ldr	r7, [pc, #64]	; (80a1574 <_GLOBAL__sub_I_SPI+0x6c>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a1534:	462a      	mov	r2, r5
 80a1536:	4631      	mov	r1, r6
 80a1538:	f000 f81e 	bl	80a1578 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a153c:	4621      	mov	r1, r4
 80a153e:	4638      	mov	r0, r7
 80a1540:	f7ff fc18 	bl	80a0d74 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a1544:	4638      	mov	r0, r7
 80a1546:	4631      	mov	r1, r6
 80a1548:	462a      	mov	r2, r5
 80a154a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80a154e:	f000 b813 	b.w	80a1578 <__aeabi_atexit>
 80a1552:	bf00      	nop
 80a1554:	20000857 	.word	0x20000857
 80a1558:	20000858 	.word	0x20000858
 80a155c:	20000855 	.word	0x20000855
 80a1560:	2000085c 	.word	0x2000085c
 80a1564:	20000856 	.word	0x20000856
 80a1568:	20000854 	.word	0x20000854
 80a156c:	080a0d65 	.word	0x080a0d65
 80a1570:	20000304 	.word	0x20000304
 80a1574:	20000868 	.word	0x20000868

080a1578 <__aeabi_atexit>:
 80a1578:	4603      	mov	r3, r0
 80a157a:	4608      	mov	r0, r1
 80a157c:	4619      	mov	r1, r3
 80a157e:	f000 bddb 	b.w	80a2138 <__cxa_atexit>
	...

080a1584 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE>:
 80a1584:	4b24      	ldr	r3, [pc, #144]	; (80a1618 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x94>)
 80a1586:	681a      	ldr	r2, [r3, #0]
 80a1588:	07d0      	lsls	r0, r2, #31
 80a158a:	bf5c      	itt	pl
 80a158c:	2201      	movpl	r2, #1
 80a158e:	601a      	strpl	r2, [r3, #0]
 80a1590:	4b22      	ldr	r3, [pc, #136]	; (80a161c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x98>)
 80a1592:	681a      	ldr	r2, [r3, #0]
 80a1594:	07d1      	lsls	r1, r2, #31
 80a1596:	bf5c      	itt	pl
 80a1598:	2201      	movpl	r2, #1
 80a159a:	601a      	strpl	r2, [r3, #0]
 80a159c:	4b20      	ldr	r3, [pc, #128]	; (80a1620 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0x9c>)
 80a159e:	681a      	ldr	r2, [r3, #0]
 80a15a0:	07d2      	lsls	r2, r2, #31
 80a15a2:	bf5c      	itt	pl
 80a15a4:	2201      	movpl	r2, #1
 80a15a6:	601a      	strpl	r2, [r3, #0]
 80a15a8:	4b1e      	ldr	r3, [pc, #120]	; (80a1624 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa0>)
 80a15aa:	681a      	ldr	r2, [r3, #0]
 80a15ac:	07d0      	lsls	r0, r2, #31
 80a15ae:	bf5c      	itt	pl
 80a15b0:	2201      	movpl	r2, #1
 80a15b2:	601a      	strpl	r2, [r3, #0]
 80a15b4:	4b1c      	ldr	r3, [pc, #112]	; (80a1628 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa4>)
 80a15b6:	681a      	ldr	r2, [r3, #0]
 80a15b8:	07d1      	lsls	r1, r2, #31
 80a15ba:	bf5c      	itt	pl
 80a15bc:	2201      	movpl	r2, #1
 80a15be:	601a      	strpl	r2, [r3, #0]
 80a15c0:	4b1a      	ldr	r3, [pc, #104]	; (80a162c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xa8>)
 80a15c2:	681a      	ldr	r2, [r3, #0]
 80a15c4:	07d2      	lsls	r2, r2, #31
 80a15c6:	bf5c      	itt	pl
 80a15c8:	2201      	movpl	r2, #1
 80a15ca:	601a      	strpl	r2, [r3, #0]
 80a15cc:	4b18      	ldr	r3, [pc, #96]	; (80a1630 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xac>)
 80a15ce:	681a      	ldr	r2, [r3, #0]
 80a15d0:	07d0      	lsls	r0, r2, #31
 80a15d2:	bf5c      	itt	pl
 80a15d4:	2201      	movpl	r2, #1
 80a15d6:	601a      	strpl	r2, [r3, #0]
 80a15d8:	4b16      	ldr	r3, [pc, #88]	; (80a1634 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb0>)
 80a15da:	681a      	ldr	r2, [r3, #0]
 80a15dc:	07d1      	lsls	r1, r2, #31
 80a15de:	bf5c      	itt	pl
 80a15e0:	2201      	movpl	r2, #1
 80a15e2:	601a      	strpl	r2, [r3, #0]
 80a15e4:	4b14      	ldr	r3, [pc, #80]	; (80a1638 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb4>)
 80a15e6:	681a      	ldr	r2, [r3, #0]
 80a15e8:	07d2      	lsls	r2, r2, #31
 80a15ea:	bf5c      	itt	pl
 80a15ec:	2201      	movpl	r2, #1
 80a15ee:	601a      	strpl	r2, [r3, #0]
 80a15f0:	4b12      	ldr	r3, [pc, #72]	; (80a163c <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xb8>)
 80a15f2:	681a      	ldr	r2, [r3, #0]
 80a15f4:	07d0      	lsls	r0, r2, #31
 80a15f6:	bf5c      	itt	pl
 80a15f8:	2201      	movpl	r2, #1
 80a15fa:	601a      	strpl	r2, [r3, #0]
 80a15fc:	4b10      	ldr	r3, [pc, #64]	; (80a1640 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xbc>)
 80a15fe:	681a      	ldr	r2, [r3, #0]
 80a1600:	07d1      	lsls	r1, r2, #31
 80a1602:	bf5c      	itt	pl
 80a1604:	2201      	movpl	r2, #1
 80a1606:	601a      	strpl	r2, [r3, #0]
 80a1608:	4b0e      	ldr	r3, [pc, #56]	; (80a1644 <_GLOBAL__sub_I__ZTSSt16__numpunct_cacheIwE+0xc0>)
 80a160a:	681a      	ldr	r2, [r3, #0]
 80a160c:	07d2      	lsls	r2, r2, #31
 80a160e:	bf5c      	itt	pl
 80a1610:	2201      	movpl	r2, #1
 80a1612:	601a      	strpl	r2, [r3, #0]
 80a1614:	4770      	bx	lr
 80a1616:	bf00      	nop
 80a1618:	200008a0 	.word	0x200008a0
 80a161c:	2000089c 	.word	0x2000089c
 80a1620:	20000898 	.word	0x20000898
 80a1624:	20000894 	.word	0x20000894
 80a1628:	20000890 	.word	0x20000890
 80a162c:	2000088c 	.word	0x2000088c
 80a1630:	20000888 	.word	0x20000888
 80a1634:	20000884 	.word	0x20000884
 80a1638:	20000880 	.word	0x20000880
 80a163c:	2000087c 	.word	0x2000087c
 80a1640:	20000878 	.word	0x20000878
 80a1644:	20000874 	.word	0x20000874

080a1648 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE>:
 80a1648:	4b24      	ldr	r3, [pc, #144]	; (80a16dc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x94>)
 80a164a:	681a      	ldr	r2, [r3, #0]
 80a164c:	07d0      	lsls	r0, r2, #31
 80a164e:	bf5c      	itt	pl
 80a1650:	2201      	movpl	r2, #1
 80a1652:	601a      	strpl	r2, [r3, #0]
 80a1654:	4b22      	ldr	r3, [pc, #136]	; (80a16e0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x98>)
 80a1656:	681a      	ldr	r2, [r3, #0]
 80a1658:	07d1      	lsls	r1, r2, #31
 80a165a:	bf5c      	itt	pl
 80a165c:	2201      	movpl	r2, #1
 80a165e:	601a      	strpl	r2, [r3, #0]
 80a1660:	4b20      	ldr	r3, [pc, #128]	; (80a16e4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0x9c>)
 80a1662:	681a      	ldr	r2, [r3, #0]
 80a1664:	07d2      	lsls	r2, r2, #31
 80a1666:	bf5c      	itt	pl
 80a1668:	2201      	movpl	r2, #1
 80a166a:	601a      	strpl	r2, [r3, #0]
 80a166c:	4b1e      	ldr	r3, [pc, #120]	; (80a16e8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa0>)
 80a166e:	681a      	ldr	r2, [r3, #0]
 80a1670:	07d0      	lsls	r0, r2, #31
 80a1672:	bf5c      	itt	pl
 80a1674:	2201      	movpl	r2, #1
 80a1676:	601a      	strpl	r2, [r3, #0]
 80a1678:	4b1c      	ldr	r3, [pc, #112]	; (80a16ec <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa4>)
 80a167a:	681a      	ldr	r2, [r3, #0]
 80a167c:	07d1      	lsls	r1, r2, #31
 80a167e:	bf5c      	itt	pl
 80a1680:	2201      	movpl	r2, #1
 80a1682:	601a      	strpl	r2, [r3, #0]
 80a1684:	4b1a      	ldr	r3, [pc, #104]	; (80a16f0 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xa8>)
 80a1686:	681a      	ldr	r2, [r3, #0]
 80a1688:	07d2      	lsls	r2, r2, #31
 80a168a:	bf5c      	itt	pl
 80a168c:	2201      	movpl	r2, #1
 80a168e:	601a      	strpl	r2, [r3, #0]
 80a1690:	4b18      	ldr	r3, [pc, #96]	; (80a16f4 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xac>)
 80a1692:	681a      	ldr	r2, [r3, #0]
 80a1694:	07d0      	lsls	r0, r2, #31
 80a1696:	bf5c      	itt	pl
 80a1698:	2201      	movpl	r2, #1
 80a169a:	601a      	strpl	r2, [r3, #0]
 80a169c:	4b16      	ldr	r3, [pc, #88]	; (80a16f8 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb0>)
 80a169e:	681a      	ldr	r2, [r3, #0]
 80a16a0:	07d1      	lsls	r1, r2, #31
 80a16a2:	bf5c      	itt	pl
 80a16a4:	2201      	movpl	r2, #1
 80a16a6:	601a      	strpl	r2, [r3, #0]
 80a16a8:	4b14      	ldr	r3, [pc, #80]	; (80a16fc <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb4>)
 80a16aa:	681a      	ldr	r2, [r3, #0]
 80a16ac:	07d2      	lsls	r2, r2, #31
 80a16ae:	bf5c      	itt	pl
 80a16b0:	2201      	movpl	r2, #1
 80a16b2:	601a      	strpl	r2, [r3, #0]
 80a16b4:	4b12      	ldr	r3, [pc, #72]	; (80a1700 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xb8>)
 80a16b6:	681a      	ldr	r2, [r3, #0]
 80a16b8:	07d0      	lsls	r0, r2, #31
 80a16ba:	bf5c      	itt	pl
 80a16bc:	2201      	movpl	r2, #1
 80a16be:	601a      	strpl	r2, [r3, #0]
 80a16c0:	4b10      	ldr	r3, [pc, #64]	; (80a1704 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xbc>)
 80a16c2:	681a      	ldr	r2, [r3, #0]
 80a16c4:	07d1      	lsls	r1, r2, #31
 80a16c6:	bf5c      	itt	pl
 80a16c8:	2201      	movpl	r2, #1
 80a16ca:	601a      	strpl	r2, [r3, #0]
 80a16cc:	4b0e      	ldr	r3, [pc, #56]	; (80a1708 <_GLOBAL__sub_I__ZTSSt21__ctype_abstract_baseIcE+0xc0>)
 80a16ce:	681a      	ldr	r2, [r3, #0]
 80a16d0:	07d2      	lsls	r2, r2, #31
 80a16d2:	bf5c      	itt	pl
 80a16d4:	2201      	movpl	r2, #1
 80a16d6:	601a      	strpl	r2, [r3, #0]
 80a16d8:	4770      	bx	lr
 80a16da:	bf00      	nop
 80a16dc:	200008d0 	.word	0x200008d0
 80a16e0:	200008cc 	.word	0x200008cc
 80a16e4:	200008c8 	.word	0x200008c8
 80a16e8:	200008c4 	.word	0x200008c4
 80a16ec:	200008c0 	.word	0x200008c0
 80a16f0:	200008bc 	.word	0x200008bc
 80a16f4:	200008b8 	.word	0x200008b8
 80a16f8:	200008b4 	.word	0x200008b4
 80a16fc:	200008b0 	.word	0x200008b0
 80a1700:	200008ac 	.word	0x200008ac
 80a1704:	200008a8 	.word	0x200008a8
 80a1708:	200008a4 	.word	0x200008a4

080a170c <__fpclassifyd>:
 80a170c:	b410      	push	{r4}
 80a170e:	f031 4400 	bics.w	r4, r1, #2147483648	; 0x80000000
 80a1712:	d008      	beq.n	80a1726 <__fpclassifyd+0x1a>
 80a1714:	4b11      	ldr	r3, [pc, #68]	; (80a175c <__fpclassifyd+0x50>)
 80a1716:	f5a1 1280 	sub.w	r2, r1, #1048576	; 0x100000
 80a171a:	429a      	cmp	r2, r3
 80a171c:	d808      	bhi.n	80a1730 <__fpclassifyd+0x24>
 80a171e:	2004      	movs	r0, #4
 80a1720:	f85d 4b04 	ldr.w	r4, [sp], #4
 80a1724:	4770      	bx	lr
 80a1726:	b918      	cbnz	r0, 80a1730 <__fpclassifyd+0x24>
 80a1728:	2002      	movs	r0, #2
 80a172a:	f85d 4b04 	ldr.w	r4, [sp], #4
 80a172e:	4770      	bx	lr
 80a1730:	f101 41ff 	add.w	r1, r1, #2139095040	; 0x7f800000
 80a1734:	4b09      	ldr	r3, [pc, #36]	; (80a175c <__fpclassifyd+0x50>)
 80a1736:	f501 01e0 	add.w	r1, r1, #7340032	; 0x700000
 80a173a:	4299      	cmp	r1, r3
 80a173c:	d9ef      	bls.n	80a171e <__fpclassifyd+0x12>
 80a173e:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 80a1742:	d201      	bcs.n	80a1748 <__fpclassifyd+0x3c>
 80a1744:	2003      	movs	r0, #3
 80a1746:	e7eb      	b.n	80a1720 <__fpclassifyd+0x14>
 80a1748:	4b05      	ldr	r3, [pc, #20]	; (80a1760 <__fpclassifyd+0x54>)
 80a174a:	429c      	cmp	r4, r3
 80a174c:	d001      	beq.n	80a1752 <__fpclassifyd+0x46>
 80a174e:	2000      	movs	r0, #0
 80a1750:	e7e6      	b.n	80a1720 <__fpclassifyd+0x14>
 80a1752:	fab0 f080 	clz	r0, r0
 80a1756:	0940      	lsrs	r0, r0, #5
 80a1758:	e7e2      	b.n	80a1720 <__fpclassifyd+0x14>
 80a175a:	bf00      	nop
 80a175c:	7fdfffff 	.word	0x7fdfffff
 80a1760:	7ff00000 	.word	0x7ff00000

080a1764 <__aeabi_drsub>:
 80a1764:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a1768:	e002      	b.n	80a1770 <__adddf3>
 80a176a:	bf00      	nop

080a176c <__aeabi_dsub>:
 80a176c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a1770 <__adddf3>:
 80a1770:	b530      	push	{r4, r5, lr}
 80a1772:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a1776:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a177a:	ea94 0f05 	teq	r4, r5
 80a177e:	bf08      	it	eq
 80a1780:	ea90 0f02 	teqeq	r0, r2
 80a1784:	bf1f      	itttt	ne
 80a1786:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a178a:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a178e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a1792:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a1796:	f000 80e2 	beq.w	80a195e <__adddf3+0x1ee>
 80a179a:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a179e:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a17a2:	bfb8      	it	lt
 80a17a4:	426d      	neglt	r5, r5
 80a17a6:	dd0c      	ble.n	80a17c2 <__adddf3+0x52>
 80a17a8:	442c      	add	r4, r5
 80a17aa:	ea80 0202 	eor.w	r2, r0, r2
 80a17ae:	ea81 0303 	eor.w	r3, r1, r3
 80a17b2:	ea82 0000 	eor.w	r0, r2, r0
 80a17b6:	ea83 0101 	eor.w	r1, r3, r1
 80a17ba:	ea80 0202 	eor.w	r2, r0, r2
 80a17be:	ea81 0303 	eor.w	r3, r1, r3
 80a17c2:	2d36      	cmp	r5, #54	; 0x36
 80a17c4:	bf88      	it	hi
 80a17c6:	bd30      	pophi	{r4, r5, pc}
 80a17c8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a17cc:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a17d0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a17d4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a17d8:	d002      	beq.n	80a17e0 <__adddf3+0x70>
 80a17da:	4240      	negs	r0, r0
 80a17dc:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a17e0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a17e4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a17e8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a17ec:	d002      	beq.n	80a17f4 <__adddf3+0x84>
 80a17ee:	4252      	negs	r2, r2
 80a17f0:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a17f4:	ea94 0f05 	teq	r4, r5
 80a17f8:	f000 80a7 	beq.w	80a194a <__adddf3+0x1da>
 80a17fc:	f1a4 0401 	sub.w	r4, r4, #1
 80a1800:	f1d5 0e20 	rsbs	lr, r5, #32
 80a1804:	db0d      	blt.n	80a1822 <__adddf3+0xb2>
 80a1806:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a180a:	fa22 f205 	lsr.w	r2, r2, r5
 80a180e:	1880      	adds	r0, r0, r2
 80a1810:	f141 0100 	adc.w	r1, r1, #0
 80a1814:	fa03 f20e 	lsl.w	r2, r3, lr
 80a1818:	1880      	adds	r0, r0, r2
 80a181a:	fa43 f305 	asr.w	r3, r3, r5
 80a181e:	4159      	adcs	r1, r3
 80a1820:	e00e      	b.n	80a1840 <__adddf3+0xd0>
 80a1822:	f1a5 0520 	sub.w	r5, r5, #32
 80a1826:	f10e 0e20 	add.w	lr, lr, #32
 80a182a:	2a01      	cmp	r2, #1
 80a182c:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a1830:	bf28      	it	cs
 80a1832:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a1836:	fa43 f305 	asr.w	r3, r3, r5
 80a183a:	18c0      	adds	r0, r0, r3
 80a183c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a1840:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a1844:	d507      	bpl.n	80a1856 <__adddf3+0xe6>
 80a1846:	f04f 0e00 	mov.w	lr, #0
 80a184a:	f1dc 0c00 	rsbs	ip, ip, #0
 80a184e:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a1852:	eb6e 0101 	sbc.w	r1, lr, r1
 80a1856:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a185a:	d31b      	bcc.n	80a1894 <__adddf3+0x124>
 80a185c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a1860:	d30c      	bcc.n	80a187c <__adddf3+0x10c>
 80a1862:	0849      	lsrs	r1, r1, #1
 80a1864:	ea5f 0030 	movs.w	r0, r0, rrx
 80a1868:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a186c:	f104 0401 	add.w	r4, r4, #1
 80a1870:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a1874:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a1878:	f080 809a 	bcs.w	80a19b0 <__adddf3+0x240>
 80a187c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a1880:	bf08      	it	eq
 80a1882:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a1886:	f150 0000 	adcs.w	r0, r0, #0
 80a188a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a188e:	ea41 0105 	orr.w	r1, r1, r5
 80a1892:	bd30      	pop	{r4, r5, pc}
 80a1894:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a1898:	4140      	adcs	r0, r0
 80a189a:	eb41 0101 	adc.w	r1, r1, r1
 80a189e:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a18a2:	f1a4 0401 	sub.w	r4, r4, #1
 80a18a6:	d1e9      	bne.n	80a187c <__adddf3+0x10c>
 80a18a8:	f091 0f00 	teq	r1, #0
 80a18ac:	bf04      	itt	eq
 80a18ae:	4601      	moveq	r1, r0
 80a18b0:	2000      	moveq	r0, #0
 80a18b2:	fab1 f381 	clz	r3, r1
 80a18b6:	bf08      	it	eq
 80a18b8:	3320      	addeq	r3, #32
 80a18ba:	f1a3 030b 	sub.w	r3, r3, #11
 80a18be:	f1b3 0220 	subs.w	r2, r3, #32
 80a18c2:	da0c      	bge.n	80a18de <__adddf3+0x16e>
 80a18c4:	320c      	adds	r2, #12
 80a18c6:	dd08      	ble.n	80a18da <__adddf3+0x16a>
 80a18c8:	f102 0c14 	add.w	ip, r2, #20
 80a18cc:	f1c2 020c 	rsb	r2, r2, #12
 80a18d0:	fa01 f00c 	lsl.w	r0, r1, ip
 80a18d4:	fa21 f102 	lsr.w	r1, r1, r2
 80a18d8:	e00c      	b.n	80a18f4 <__adddf3+0x184>
 80a18da:	f102 0214 	add.w	r2, r2, #20
 80a18de:	bfd8      	it	le
 80a18e0:	f1c2 0c20 	rsble	ip, r2, #32
 80a18e4:	fa01 f102 	lsl.w	r1, r1, r2
 80a18e8:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a18ec:	bfdc      	itt	le
 80a18ee:	ea41 010c 	orrle.w	r1, r1, ip
 80a18f2:	4090      	lslle	r0, r2
 80a18f4:	1ae4      	subs	r4, r4, r3
 80a18f6:	bfa2      	ittt	ge
 80a18f8:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a18fc:	4329      	orrge	r1, r5
 80a18fe:	bd30      	popge	{r4, r5, pc}
 80a1900:	ea6f 0404 	mvn.w	r4, r4
 80a1904:	3c1f      	subs	r4, #31
 80a1906:	da1c      	bge.n	80a1942 <__adddf3+0x1d2>
 80a1908:	340c      	adds	r4, #12
 80a190a:	dc0e      	bgt.n	80a192a <__adddf3+0x1ba>
 80a190c:	f104 0414 	add.w	r4, r4, #20
 80a1910:	f1c4 0220 	rsb	r2, r4, #32
 80a1914:	fa20 f004 	lsr.w	r0, r0, r4
 80a1918:	fa01 f302 	lsl.w	r3, r1, r2
 80a191c:	ea40 0003 	orr.w	r0, r0, r3
 80a1920:	fa21 f304 	lsr.w	r3, r1, r4
 80a1924:	ea45 0103 	orr.w	r1, r5, r3
 80a1928:	bd30      	pop	{r4, r5, pc}
 80a192a:	f1c4 040c 	rsb	r4, r4, #12
 80a192e:	f1c4 0220 	rsb	r2, r4, #32
 80a1932:	fa20 f002 	lsr.w	r0, r0, r2
 80a1936:	fa01 f304 	lsl.w	r3, r1, r4
 80a193a:	ea40 0003 	orr.w	r0, r0, r3
 80a193e:	4629      	mov	r1, r5
 80a1940:	bd30      	pop	{r4, r5, pc}
 80a1942:	fa21 f004 	lsr.w	r0, r1, r4
 80a1946:	4629      	mov	r1, r5
 80a1948:	bd30      	pop	{r4, r5, pc}
 80a194a:	f094 0f00 	teq	r4, #0
 80a194e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a1952:	bf06      	itte	eq
 80a1954:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a1958:	3401      	addeq	r4, #1
 80a195a:	3d01      	subne	r5, #1
 80a195c:	e74e      	b.n	80a17fc <__adddf3+0x8c>
 80a195e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a1962:	bf18      	it	ne
 80a1964:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a1968:	d029      	beq.n	80a19be <__adddf3+0x24e>
 80a196a:	ea94 0f05 	teq	r4, r5
 80a196e:	bf08      	it	eq
 80a1970:	ea90 0f02 	teqeq	r0, r2
 80a1974:	d005      	beq.n	80a1982 <__adddf3+0x212>
 80a1976:	ea54 0c00 	orrs.w	ip, r4, r0
 80a197a:	bf04      	itt	eq
 80a197c:	4619      	moveq	r1, r3
 80a197e:	4610      	moveq	r0, r2
 80a1980:	bd30      	pop	{r4, r5, pc}
 80a1982:	ea91 0f03 	teq	r1, r3
 80a1986:	bf1e      	ittt	ne
 80a1988:	2100      	movne	r1, #0
 80a198a:	2000      	movne	r0, #0
 80a198c:	bd30      	popne	{r4, r5, pc}
 80a198e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a1992:	d105      	bne.n	80a19a0 <__adddf3+0x230>
 80a1994:	0040      	lsls	r0, r0, #1
 80a1996:	4149      	adcs	r1, r1
 80a1998:	bf28      	it	cs
 80a199a:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a199e:	bd30      	pop	{r4, r5, pc}
 80a19a0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a19a4:	bf3c      	itt	cc
 80a19a6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a19aa:	bd30      	popcc	{r4, r5, pc}
 80a19ac:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a19b0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a19b4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a19b8:	f04f 0000 	mov.w	r0, #0
 80a19bc:	bd30      	pop	{r4, r5, pc}
 80a19be:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a19c2:	bf1a      	itte	ne
 80a19c4:	4619      	movne	r1, r3
 80a19c6:	4610      	movne	r0, r2
 80a19c8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a19cc:	bf1c      	itt	ne
 80a19ce:	460b      	movne	r3, r1
 80a19d0:	4602      	movne	r2, r0
 80a19d2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a19d6:	bf06      	itte	eq
 80a19d8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a19dc:	ea91 0f03 	teqeq	r1, r3
 80a19e0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a19e4:	bd30      	pop	{r4, r5, pc}
 80a19e6:	bf00      	nop

080a19e8 <__aeabi_ui2d>:
 80a19e8:	f090 0f00 	teq	r0, #0
 80a19ec:	bf04      	itt	eq
 80a19ee:	2100      	moveq	r1, #0
 80a19f0:	4770      	bxeq	lr
 80a19f2:	b530      	push	{r4, r5, lr}
 80a19f4:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a19f8:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a19fc:	f04f 0500 	mov.w	r5, #0
 80a1a00:	f04f 0100 	mov.w	r1, #0
 80a1a04:	e750      	b.n	80a18a8 <__adddf3+0x138>
 80a1a06:	bf00      	nop

080a1a08 <__aeabi_i2d>:
 80a1a08:	f090 0f00 	teq	r0, #0
 80a1a0c:	bf04      	itt	eq
 80a1a0e:	2100      	moveq	r1, #0
 80a1a10:	4770      	bxeq	lr
 80a1a12:	b530      	push	{r4, r5, lr}
 80a1a14:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a1a18:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a1a1c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a1a20:	bf48      	it	mi
 80a1a22:	4240      	negmi	r0, r0
 80a1a24:	f04f 0100 	mov.w	r1, #0
 80a1a28:	e73e      	b.n	80a18a8 <__adddf3+0x138>
 80a1a2a:	bf00      	nop

080a1a2c <__aeabi_f2d>:
 80a1a2c:	0042      	lsls	r2, r0, #1
 80a1a2e:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a1a32:	ea4f 0131 	mov.w	r1, r1, rrx
 80a1a36:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a1a3a:	bf1f      	itttt	ne
 80a1a3c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a1a40:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a1a44:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a1a48:	4770      	bxne	lr
 80a1a4a:	f092 0f00 	teq	r2, #0
 80a1a4e:	bf14      	ite	ne
 80a1a50:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a1a54:	4770      	bxeq	lr
 80a1a56:	b530      	push	{r4, r5, lr}
 80a1a58:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a1a5c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a1a60:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a1a64:	e720      	b.n	80a18a8 <__adddf3+0x138>
 80a1a66:	bf00      	nop

080a1a68 <__aeabi_ul2d>:
 80a1a68:	ea50 0201 	orrs.w	r2, r0, r1
 80a1a6c:	bf08      	it	eq
 80a1a6e:	4770      	bxeq	lr
 80a1a70:	b530      	push	{r4, r5, lr}
 80a1a72:	f04f 0500 	mov.w	r5, #0
 80a1a76:	e00a      	b.n	80a1a8e <__aeabi_l2d+0x16>

080a1a78 <__aeabi_l2d>:
 80a1a78:	ea50 0201 	orrs.w	r2, r0, r1
 80a1a7c:	bf08      	it	eq
 80a1a7e:	4770      	bxeq	lr
 80a1a80:	b530      	push	{r4, r5, lr}
 80a1a82:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a1a86:	d502      	bpl.n	80a1a8e <__aeabi_l2d+0x16>
 80a1a88:	4240      	negs	r0, r0
 80a1a8a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a1a8e:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a1a92:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a1a96:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a1a9a:	f43f aedc 	beq.w	80a1856 <__adddf3+0xe6>
 80a1a9e:	f04f 0203 	mov.w	r2, #3
 80a1aa2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a1aa6:	bf18      	it	ne
 80a1aa8:	3203      	addne	r2, #3
 80a1aaa:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a1aae:	bf18      	it	ne
 80a1ab0:	3203      	addne	r2, #3
 80a1ab2:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a1ab6:	f1c2 0320 	rsb	r3, r2, #32
 80a1aba:	fa00 fc03 	lsl.w	ip, r0, r3
 80a1abe:	fa20 f002 	lsr.w	r0, r0, r2
 80a1ac2:	fa01 fe03 	lsl.w	lr, r1, r3
 80a1ac6:	ea40 000e 	orr.w	r0, r0, lr
 80a1aca:	fa21 f102 	lsr.w	r1, r1, r2
 80a1ace:	4414      	add	r4, r2
 80a1ad0:	e6c1      	b.n	80a1856 <__adddf3+0xe6>
 80a1ad2:	bf00      	nop

080a1ad4 <__aeabi_dmul>:
 80a1ad4:	b570      	push	{r4, r5, r6, lr}
 80a1ad6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a1ada:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a1ade:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a1ae2:	bf1d      	ittte	ne
 80a1ae4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a1ae8:	ea94 0f0c 	teqne	r4, ip
 80a1aec:	ea95 0f0c 	teqne	r5, ip
 80a1af0:	f000 f8de 	bleq	80a1cb0 <__aeabi_dmul+0x1dc>
 80a1af4:	442c      	add	r4, r5
 80a1af6:	ea81 0603 	eor.w	r6, r1, r3
 80a1afa:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a1afe:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a1b02:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a1b06:	bf18      	it	ne
 80a1b08:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a1b0c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a1b10:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a1b14:	d038      	beq.n	80a1b88 <__aeabi_dmul+0xb4>
 80a1b16:	fba0 ce02 	umull	ip, lr, r0, r2
 80a1b1a:	f04f 0500 	mov.w	r5, #0
 80a1b1e:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a1b22:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a1b26:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a1b2a:	f04f 0600 	mov.w	r6, #0
 80a1b2e:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a1b32:	f09c 0f00 	teq	ip, #0
 80a1b36:	bf18      	it	ne
 80a1b38:	f04e 0e01 	orrne.w	lr, lr, #1
 80a1b3c:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a1b40:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a1b44:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a1b48:	d204      	bcs.n	80a1b54 <__aeabi_dmul+0x80>
 80a1b4a:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a1b4e:	416d      	adcs	r5, r5
 80a1b50:	eb46 0606 	adc.w	r6, r6, r6
 80a1b54:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a1b58:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a1b5c:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a1b60:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a1b64:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a1b68:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a1b6c:	bf88      	it	hi
 80a1b6e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a1b72:	d81e      	bhi.n	80a1bb2 <__aeabi_dmul+0xde>
 80a1b74:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a1b78:	bf08      	it	eq
 80a1b7a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a1b7e:	f150 0000 	adcs.w	r0, r0, #0
 80a1b82:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a1b86:	bd70      	pop	{r4, r5, r6, pc}
 80a1b88:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a1b8c:	ea46 0101 	orr.w	r1, r6, r1
 80a1b90:	ea40 0002 	orr.w	r0, r0, r2
 80a1b94:	ea81 0103 	eor.w	r1, r1, r3
 80a1b98:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a1b9c:	bfc2      	ittt	gt
 80a1b9e:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a1ba2:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a1ba6:	bd70      	popgt	{r4, r5, r6, pc}
 80a1ba8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a1bac:	f04f 0e00 	mov.w	lr, #0
 80a1bb0:	3c01      	subs	r4, #1
 80a1bb2:	f300 80ab 	bgt.w	80a1d0c <__aeabi_dmul+0x238>
 80a1bb6:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a1bba:	bfde      	ittt	le
 80a1bbc:	2000      	movle	r0, #0
 80a1bbe:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a1bc2:	bd70      	pople	{r4, r5, r6, pc}
 80a1bc4:	f1c4 0400 	rsb	r4, r4, #0
 80a1bc8:	3c20      	subs	r4, #32
 80a1bca:	da35      	bge.n	80a1c38 <__aeabi_dmul+0x164>
 80a1bcc:	340c      	adds	r4, #12
 80a1bce:	dc1b      	bgt.n	80a1c08 <__aeabi_dmul+0x134>
 80a1bd0:	f104 0414 	add.w	r4, r4, #20
 80a1bd4:	f1c4 0520 	rsb	r5, r4, #32
 80a1bd8:	fa00 f305 	lsl.w	r3, r0, r5
 80a1bdc:	fa20 f004 	lsr.w	r0, r0, r4
 80a1be0:	fa01 f205 	lsl.w	r2, r1, r5
 80a1be4:	ea40 0002 	orr.w	r0, r0, r2
 80a1be8:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a1bec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a1bf0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a1bf4:	fa21 f604 	lsr.w	r6, r1, r4
 80a1bf8:	eb42 0106 	adc.w	r1, r2, r6
 80a1bfc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a1c00:	bf08      	it	eq
 80a1c02:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a1c06:	bd70      	pop	{r4, r5, r6, pc}
 80a1c08:	f1c4 040c 	rsb	r4, r4, #12
 80a1c0c:	f1c4 0520 	rsb	r5, r4, #32
 80a1c10:	fa00 f304 	lsl.w	r3, r0, r4
 80a1c14:	fa20 f005 	lsr.w	r0, r0, r5
 80a1c18:	fa01 f204 	lsl.w	r2, r1, r4
 80a1c1c:	ea40 0002 	orr.w	r0, r0, r2
 80a1c20:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a1c24:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a1c28:	f141 0100 	adc.w	r1, r1, #0
 80a1c2c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a1c30:	bf08      	it	eq
 80a1c32:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a1c36:	bd70      	pop	{r4, r5, r6, pc}
 80a1c38:	f1c4 0520 	rsb	r5, r4, #32
 80a1c3c:	fa00 f205 	lsl.w	r2, r0, r5
 80a1c40:	ea4e 0e02 	orr.w	lr, lr, r2
 80a1c44:	fa20 f304 	lsr.w	r3, r0, r4
 80a1c48:	fa01 f205 	lsl.w	r2, r1, r5
 80a1c4c:	ea43 0302 	orr.w	r3, r3, r2
 80a1c50:	fa21 f004 	lsr.w	r0, r1, r4
 80a1c54:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a1c58:	fa21 f204 	lsr.w	r2, r1, r4
 80a1c5c:	ea20 0002 	bic.w	r0, r0, r2
 80a1c60:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a1c64:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a1c68:	bf08      	it	eq
 80a1c6a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a1c6e:	bd70      	pop	{r4, r5, r6, pc}
 80a1c70:	f094 0f00 	teq	r4, #0
 80a1c74:	d10f      	bne.n	80a1c96 <__aeabi_dmul+0x1c2>
 80a1c76:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a1c7a:	0040      	lsls	r0, r0, #1
 80a1c7c:	eb41 0101 	adc.w	r1, r1, r1
 80a1c80:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a1c84:	bf08      	it	eq
 80a1c86:	3c01      	subeq	r4, #1
 80a1c88:	d0f7      	beq.n	80a1c7a <__aeabi_dmul+0x1a6>
 80a1c8a:	ea41 0106 	orr.w	r1, r1, r6
 80a1c8e:	f095 0f00 	teq	r5, #0
 80a1c92:	bf18      	it	ne
 80a1c94:	4770      	bxne	lr
 80a1c96:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a1c9a:	0052      	lsls	r2, r2, #1
 80a1c9c:	eb43 0303 	adc.w	r3, r3, r3
 80a1ca0:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a1ca4:	bf08      	it	eq
 80a1ca6:	3d01      	subeq	r5, #1
 80a1ca8:	d0f7      	beq.n	80a1c9a <__aeabi_dmul+0x1c6>
 80a1caa:	ea43 0306 	orr.w	r3, r3, r6
 80a1cae:	4770      	bx	lr
 80a1cb0:	ea94 0f0c 	teq	r4, ip
 80a1cb4:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a1cb8:	bf18      	it	ne
 80a1cba:	ea95 0f0c 	teqne	r5, ip
 80a1cbe:	d00c      	beq.n	80a1cda <__aeabi_dmul+0x206>
 80a1cc0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a1cc4:	bf18      	it	ne
 80a1cc6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a1cca:	d1d1      	bne.n	80a1c70 <__aeabi_dmul+0x19c>
 80a1ccc:	ea81 0103 	eor.w	r1, r1, r3
 80a1cd0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a1cd4:	f04f 0000 	mov.w	r0, #0
 80a1cd8:	bd70      	pop	{r4, r5, r6, pc}
 80a1cda:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a1cde:	bf06      	itte	eq
 80a1ce0:	4610      	moveq	r0, r2
 80a1ce2:	4619      	moveq	r1, r3
 80a1ce4:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a1ce8:	d019      	beq.n	80a1d1e <__aeabi_dmul+0x24a>
 80a1cea:	ea94 0f0c 	teq	r4, ip
 80a1cee:	d102      	bne.n	80a1cf6 <__aeabi_dmul+0x222>
 80a1cf0:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a1cf4:	d113      	bne.n	80a1d1e <__aeabi_dmul+0x24a>
 80a1cf6:	ea95 0f0c 	teq	r5, ip
 80a1cfa:	d105      	bne.n	80a1d08 <__aeabi_dmul+0x234>
 80a1cfc:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a1d00:	bf1c      	itt	ne
 80a1d02:	4610      	movne	r0, r2
 80a1d04:	4619      	movne	r1, r3
 80a1d06:	d10a      	bne.n	80a1d1e <__aeabi_dmul+0x24a>
 80a1d08:	ea81 0103 	eor.w	r1, r1, r3
 80a1d0c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a1d10:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a1d14:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a1d18:	f04f 0000 	mov.w	r0, #0
 80a1d1c:	bd70      	pop	{r4, r5, r6, pc}
 80a1d1e:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a1d22:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a1d26:	bd70      	pop	{r4, r5, r6, pc}

080a1d28 <__aeabi_ddiv>:
 80a1d28:	b570      	push	{r4, r5, r6, lr}
 80a1d2a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a1d2e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a1d32:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a1d36:	bf1d      	ittte	ne
 80a1d38:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a1d3c:	ea94 0f0c 	teqne	r4, ip
 80a1d40:	ea95 0f0c 	teqne	r5, ip
 80a1d44:	f000 f8a7 	bleq	80a1e96 <__aeabi_ddiv+0x16e>
 80a1d48:	eba4 0405 	sub.w	r4, r4, r5
 80a1d4c:	ea81 0e03 	eor.w	lr, r1, r3
 80a1d50:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a1d54:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a1d58:	f000 8088 	beq.w	80a1e6c <__aeabi_ddiv+0x144>
 80a1d5c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a1d60:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a1d64:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a1d68:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a1d6c:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a1d70:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a1d74:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a1d78:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a1d7c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a1d80:	429d      	cmp	r5, r3
 80a1d82:	bf08      	it	eq
 80a1d84:	4296      	cmpeq	r6, r2
 80a1d86:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a1d8a:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a1d8e:	d202      	bcs.n	80a1d96 <__aeabi_ddiv+0x6e>
 80a1d90:	085b      	lsrs	r3, r3, #1
 80a1d92:	ea4f 0232 	mov.w	r2, r2, rrx
 80a1d96:	1ab6      	subs	r6, r6, r2
 80a1d98:	eb65 0503 	sbc.w	r5, r5, r3
 80a1d9c:	085b      	lsrs	r3, r3, #1
 80a1d9e:	ea4f 0232 	mov.w	r2, r2, rrx
 80a1da2:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a1da6:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a1daa:	ebb6 0e02 	subs.w	lr, r6, r2
 80a1dae:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a1db2:	bf22      	ittt	cs
 80a1db4:	1ab6      	subcs	r6, r6, r2
 80a1db6:	4675      	movcs	r5, lr
 80a1db8:	ea40 000c 	orrcs.w	r0, r0, ip
 80a1dbc:	085b      	lsrs	r3, r3, #1
 80a1dbe:	ea4f 0232 	mov.w	r2, r2, rrx
 80a1dc2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a1dc6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a1dca:	bf22      	ittt	cs
 80a1dcc:	1ab6      	subcs	r6, r6, r2
 80a1dce:	4675      	movcs	r5, lr
 80a1dd0:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a1dd4:	085b      	lsrs	r3, r3, #1
 80a1dd6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a1dda:	ebb6 0e02 	subs.w	lr, r6, r2
 80a1dde:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a1de2:	bf22      	ittt	cs
 80a1de4:	1ab6      	subcs	r6, r6, r2
 80a1de6:	4675      	movcs	r5, lr
 80a1de8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a1dec:	085b      	lsrs	r3, r3, #1
 80a1dee:	ea4f 0232 	mov.w	r2, r2, rrx
 80a1df2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a1df6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a1dfa:	bf22      	ittt	cs
 80a1dfc:	1ab6      	subcs	r6, r6, r2
 80a1dfe:	4675      	movcs	r5, lr
 80a1e00:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a1e04:	ea55 0e06 	orrs.w	lr, r5, r6
 80a1e08:	d018      	beq.n	80a1e3c <__aeabi_ddiv+0x114>
 80a1e0a:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a1e0e:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a1e12:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a1e16:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a1e1a:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a1e1e:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a1e22:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a1e26:	d1c0      	bne.n	80a1daa <__aeabi_ddiv+0x82>
 80a1e28:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a1e2c:	d10b      	bne.n	80a1e46 <__aeabi_ddiv+0x11e>
 80a1e2e:	ea41 0100 	orr.w	r1, r1, r0
 80a1e32:	f04f 0000 	mov.w	r0, #0
 80a1e36:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a1e3a:	e7b6      	b.n	80a1daa <__aeabi_ddiv+0x82>
 80a1e3c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a1e40:	bf04      	itt	eq
 80a1e42:	4301      	orreq	r1, r0
 80a1e44:	2000      	moveq	r0, #0
 80a1e46:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a1e4a:	bf88      	it	hi
 80a1e4c:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a1e50:	f63f aeaf 	bhi.w	80a1bb2 <__aeabi_dmul+0xde>
 80a1e54:	ebb5 0c03 	subs.w	ip, r5, r3
 80a1e58:	bf04      	itt	eq
 80a1e5a:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a1e5e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a1e62:	f150 0000 	adcs.w	r0, r0, #0
 80a1e66:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a1e6a:	bd70      	pop	{r4, r5, r6, pc}
 80a1e6c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a1e70:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a1e74:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a1e78:	bfc2      	ittt	gt
 80a1e7a:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a1e7e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a1e82:	bd70      	popgt	{r4, r5, r6, pc}
 80a1e84:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a1e88:	f04f 0e00 	mov.w	lr, #0
 80a1e8c:	3c01      	subs	r4, #1
 80a1e8e:	e690      	b.n	80a1bb2 <__aeabi_dmul+0xde>
 80a1e90:	ea45 0e06 	orr.w	lr, r5, r6
 80a1e94:	e68d      	b.n	80a1bb2 <__aeabi_dmul+0xde>
 80a1e96:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a1e9a:	ea94 0f0c 	teq	r4, ip
 80a1e9e:	bf08      	it	eq
 80a1ea0:	ea95 0f0c 	teqeq	r5, ip
 80a1ea4:	f43f af3b 	beq.w	80a1d1e <__aeabi_dmul+0x24a>
 80a1ea8:	ea94 0f0c 	teq	r4, ip
 80a1eac:	d10a      	bne.n	80a1ec4 <__aeabi_ddiv+0x19c>
 80a1eae:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a1eb2:	f47f af34 	bne.w	80a1d1e <__aeabi_dmul+0x24a>
 80a1eb6:	ea95 0f0c 	teq	r5, ip
 80a1eba:	f47f af25 	bne.w	80a1d08 <__aeabi_dmul+0x234>
 80a1ebe:	4610      	mov	r0, r2
 80a1ec0:	4619      	mov	r1, r3
 80a1ec2:	e72c      	b.n	80a1d1e <__aeabi_dmul+0x24a>
 80a1ec4:	ea95 0f0c 	teq	r5, ip
 80a1ec8:	d106      	bne.n	80a1ed8 <__aeabi_ddiv+0x1b0>
 80a1eca:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a1ece:	f43f aefd 	beq.w	80a1ccc <__aeabi_dmul+0x1f8>
 80a1ed2:	4610      	mov	r0, r2
 80a1ed4:	4619      	mov	r1, r3
 80a1ed6:	e722      	b.n	80a1d1e <__aeabi_dmul+0x24a>
 80a1ed8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a1edc:	bf18      	it	ne
 80a1ede:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a1ee2:	f47f aec5 	bne.w	80a1c70 <__aeabi_dmul+0x19c>
 80a1ee6:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a1eea:	f47f af0d 	bne.w	80a1d08 <__aeabi_dmul+0x234>
 80a1eee:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a1ef2:	f47f aeeb 	bne.w	80a1ccc <__aeabi_dmul+0x1f8>
 80a1ef6:	e712      	b.n	80a1d1e <__aeabi_dmul+0x24a>

080a1ef8 <__gedf2>:
 80a1ef8:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80a1efc:	e006      	b.n	80a1f0c <__cmpdf2+0x4>
 80a1efe:	bf00      	nop

080a1f00 <__ledf2>:
 80a1f00:	f04f 0c01 	mov.w	ip, #1
 80a1f04:	e002      	b.n	80a1f0c <__cmpdf2+0x4>
 80a1f06:	bf00      	nop

080a1f08 <__cmpdf2>:
 80a1f08:	f04f 0c01 	mov.w	ip, #1
 80a1f0c:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a1f10:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a1f14:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a1f18:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a1f1c:	bf18      	it	ne
 80a1f1e:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80a1f22:	d01b      	beq.n	80a1f5c <__cmpdf2+0x54>
 80a1f24:	b001      	add	sp, #4
 80a1f26:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80a1f2a:	bf0c      	ite	eq
 80a1f2c:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80a1f30:	ea91 0f03 	teqne	r1, r3
 80a1f34:	bf02      	ittt	eq
 80a1f36:	ea90 0f02 	teqeq	r0, r2
 80a1f3a:	2000      	moveq	r0, #0
 80a1f3c:	4770      	bxeq	lr
 80a1f3e:	f110 0f00 	cmn.w	r0, #0
 80a1f42:	ea91 0f03 	teq	r1, r3
 80a1f46:	bf58      	it	pl
 80a1f48:	4299      	cmppl	r1, r3
 80a1f4a:	bf08      	it	eq
 80a1f4c:	4290      	cmpeq	r0, r2
 80a1f4e:	bf2c      	ite	cs
 80a1f50:	17d8      	asrcs	r0, r3, #31
 80a1f52:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80a1f56:	f040 0001 	orr.w	r0, r0, #1
 80a1f5a:	4770      	bx	lr
 80a1f5c:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a1f60:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a1f64:	d102      	bne.n	80a1f6c <__cmpdf2+0x64>
 80a1f66:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a1f6a:	d107      	bne.n	80a1f7c <__cmpdf2+0x74>
 80a1f6c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a1f70:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a1f74:	d1d6      	bne.n	80a1f24 <__cmpdf2+0x1c>
 80a1f76:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a1f7a:	d0d3      	beq.n	80a1f24 <__cmpdf2+0x1c>
 80a1f7c:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a1f80:	4770      	bx	lr
 80a1f82:	bf00      	nop

080a1f84 <__aeabi_cdrcmple>:
 80a1f84:	4684      	mov	ip, r0
 80a1f86:	4610      	mov	r0, r2
 80a1f88:	4662      	mov	r2, ip
 80a1f8a:	468c      	mov	ip, r1
 80a1f8c:	4619      	mov	r1, r3
 80a1f8e:	4663      	mov	r3, ip
 80a1f90:	e000      	b.n	80a1f94 <__aeabi_cdcmpeq>
 80a1f92:	bf00      	nop

080a1f94 <__aeabi_cdcmpeq>:
 80a1f94:	b501      	push	{r0, lr}
 80a1f96:	f7ff ffb7 	bl	80a1f08 <__cmpdf2>
 80a1f9a:	2800      	cmp	r0, #0
 80a1f9c:	bf48      	it	mi
 80a1f9e:	f110 0f00 	cmnmi.w	r0, #0
 80a1fa2:	bd01      	pop	{r0, pc}

080a1fa4 <__aeabi_dcmpeq>:
 80a1fa4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a1fa8:	f7ff fff4 	bl	80a1f94 <__aeabi_cdcmpeq>
 80a1fac:	bf0c      	ite	eq
 80a1fae:	2001      	moveq	r0, #1
 80a1fb0:	2000      	movne	r0, #0
 80a1fb2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a1fb6:	bf00      	nop

080a1fb8 <__aeabi_dcmplt>:
 80a1fb8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a1fbc:	f7ff ffea 	bl	80a1f94 <__aeabi_cdcmpeq>
 80a1fc0:	bf34      	ite	cc
 80a1fc2:	2001      	movcc	r0, #1
 80a1fc4:	2000      	movcs	r0, #0
 80a1fc6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a1fca:	bf00      	nop

080a1fcc <__aeabi_dcmple>:
 80a1fcc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a1fd0:	f7ff ffe0 	bl	80a1f94 <__aeabi_cdcmpeq>
 80a1fd4:	bf94      	ite	ls
 80a1fd6:	2001      	movls	r0, #1
 80a1fd8:	2000      	movhi	r0, #0
 80a1fda:	f85d fb08 	ldr.w	pc, [sp], #8
 80a1fde:	bf00      	nop

080a1fe0 <__aeabi_dcmpge>:
 80a1fe0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a1fe4:	f7ff ffce 	bl	80a1f84 <__aeabi_cdrcmple>
 80a1fe8:	bf94      	ite	ls
 80a1fea:	2001      	movls	r0, #1
 80a1fec:	2000      	movhi	r0, #0
 80a1fee:	f85d fb08 	ldr.w	pc, [sp], #8
 80a1ff2:	bf00      	nop

080a1ff4 <__aeabi_dcmpgt>:
 80a1ff4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a1ff8:	f7ff ffc4 	bl	80a1f84 <__aeabi_cdrcmple>
 80a1ffc:	bf34      	ite	cc
 80a1ffe:	2001      	movcc	r0, #1
 80a2000:	2000      	movcs	r0, #0
 80a2002:	f85d fb08 	ldr.w	pc, [sp], #8
 80a2006:	bf00      	nop

080a2008 <__aeabi_d2iz>:
 80a2008:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a200c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a2010:	d215      	bcs.n	80a203e <__aeabi_d2iz+0x36>
 80a2012:	d511      	bpl.n	80a2038 <__aeabi_d2iz+0x30>
 80a2014:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a2018:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a201c:	d912      	bls.n	80a2044 <__aeabi_d2iz+0x3c>
 80a201e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a2022:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a2026:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a202a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a202e:	fa23 f002 	lsr.w	r0, r3, r2
 80a2032:	bf18      	it	ne
 80a2034:	4240      	negne	r0, r0
 80a2036:	4770      	bx	lr
 80a2038:	f04f 0000 	mov.w	r0, #0
 80a203c:	4770      	bx	lr
 80a203e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a2042:	d105      	bne.n	80a2050 <__aeabi_d2iz+0x48>
 80a2044:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a2048:	bf08      	it	eq
 80a204a:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a204e:	4770      	bx	lr
 80a2050:	f04f 0000 	mov.w	r0, #0
 80a2054:	4770      	bx	lr
 80a2056:	bf00      	nop

080a2058 <__aeabi_d2uiz>:
 80a2058:	004a      	lsls	r2, r1, #1
 80a205a:	d211      	bcs.n	80a2080 <__aeabi_d2uiz+0x28>
 80a205c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a2060:	d211      	bcs.n	80a2086 <__aeabi_d2uiz+0x2e>
 80a2062:	d50d      	bpl.n	80a2080 <__aeabi_d2uiz+0x28>
 80a2064:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a2068:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a206c:	d40e      	bmi.n	80a208c <__aeabi_d2uiz+0x34>
 80a206e:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a2072:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a2076:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a207a:	fa23 f002 	lsr.w	r0, r3, r2
 80a207e:	4770      	bx	lr
 80a2080:	f04f 0000 	mov.w	r0, #0
 80a2084:	4770      	bx	lr
 80a2086:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a208a:	d102      	bne.n	80a2092 <__aeabi_d2uiz+0x3a>
 80a208c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a2090:	4770      	bx	lr
 80a2092:	f04f 0000 	mov.w	r0, #0
 80a2096:	4770      	bx	lr

080a2098 <__aeabi_d2f>:
 80a2098:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a209c:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 80a20a0:	bf24      	itt	cs
 80a20a2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 80a20a6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 80a20aa:	d90d      	bls.n	80a20c8 <__aeabi_d2f+0x30>
 80a20ac:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a20b0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80a20b4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80a20b8:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 80a20bc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80a20c0:	bf08      	it	eq
 80a20c2:	f020 0001 	biceq.w	r0, r0, #1
 80a20c6:	4770      	bx	lr
 80a20c8:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 80a20cc:	d121      	bne.n	80a2112 <__aeabi_d2f+0x7a>
 80a20ce:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 80a20d2:	bfbc      	itt	lt
 80a20d4:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 80a20d8:	4770      	bxlt	lr
 80a20da:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a20de:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80a20e2:	f1c2 0218 	rsb	r2, r2, #24
 80a20e6:	f1c2 0c20 	rsb	ip, r2, #32
 80a20ea:	fa10 f30c 	lsls.w	r3, r0, ip
 80a20ee:	fa20 f002 	lsr.w	r0, r0, r2
 80a20f2:	bf18      	it	ne
 80a20f4:	f040 0001 	orrne.w	r0, r0, #1
 80a20f8:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a20fc:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 80a2100:	fa03 fc0c 	lsl.w	ip, r3, ip
 80a2104:	ea40 000c 	orr.w	r0, r0, ip
 80a2108:	fa23 f302 	lsr.w	r3, r3, r2
 80a210c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 80a2110:	e7cc      	b.n	80a20ac <__aeabi_d2f+0x14>
 80a2112:	ea7f 5362 	mvns.w	r3, r2, asr #21
 80a2116:	d107      	bne.n	80a2128 <__aeabi_d2f+0x90>
 80a2118:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 80a211c:	bf1e      	ittt	ne
 80a211e:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 80a2122:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 80a2126:	4770      	bxne	lr
 80a2128:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 80a212c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a2130:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a2134:	4770      	bx	lr
 80a2136:	bf00      	nop

080a2138 <__cxa_atexit>:
 80a2138:	b538      	push	{r3, r4, r5, lr}
 80a213a:	4605      	mov	r5, r0
 80a213c:	4804      	ldr	r0, [pc, #16]	; (80a2150 <__cxa_atexit+0x18>)
 80a213e:	460c      	mov	r4, r1
 80a2140:	4613      	mov	r3, r2
 80a2142:	b120      	cbz	r0, 80a214e <__cxa_atexit+0x16>
 80a2144:	2002      	movs	r0, #2
 80a2146:	4629      	mov	r1, r5
 80a2148:	4622      	mov	r2, r4
 80a214a:	f3af 8000 	nop.w
 80a214e:	bd38      	pop	{r3, r4, r5, pc}
 80a2150:	00000000 	.word	0x00000000

080a2154 <memcpy>:
 80a2154:	b510      	push	{r4, lr}
 80a2156:	1e43      	subs	r3, r0, #1
 80a2158:	440a      	add	r2, r1
 80a215a:	4291      	cmp	r1, r2
 80a215c:	d004      	beq.n	80a2168 <memcpy+0x14>
 80a215e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a2162:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a2166:	e7f8      	b.n	80a215a <memcpy+0x6>
 80a2168:	bd10      	pop	{r4, pc}

080a216a <memset>:
 80a216a:	4603      	mov	r3, r0
 80a216c:	4402      	add	r2, r0
 80a216e:	4293      	cmp	r3, r2
 80a2170:	d002      	beq.n	80a2178 <memset+0xe>
 80a2172:	f803 1b01 	strb.w	r1, [r3], #1
 80a2176:	e7fa      	b.n	80a216e <memset+0x4>
 80a2178:	4770      	bx	lr

080a217a <strlen>:
 80a217a:	4603      	mov	r3, r0
 80a217c:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a2180:	2a00      	cmp	r2, #0
 80a2182:	d1fb      	bne.n	80a217c <strlen+0x2>
 80a2184:	1a18      	subs	r0, r3, r0
 80a2186:	3801      	subs	r0, #1
 80a2188:	4770      	bx	lr

080a218a <strncpy>:
 80a218a:	4603      	mov	r3, r0
 80a218c:	b510      	push	{r4, lr}
 80a218e:	b132      	cbz	r2, 80a219e <strncpy+0x14>
 80a2190:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a2194:	3a01      	subs	r2, #1
 80a2196:	f803 4b01 	strb.w	r4, [r3], #1
 80a219a:	2c00      	cmp	r4, #0
 80a219c:	d1f7      	bne.n	80a218e <strncpy+0x4>
 80a219e:	441a      	add	r2, r3
 80a21a0:	4293      	cmp	r3, r2
 80a21a2:	d003      	beq.n	80a21ac <strncpy+0x22>
 80a21a4:	2100      	movs	r1, #0
 80a21a6:	f803 1b01 	strb.w	r1, [r3], #1
 80a21aa:	e7f9      	b.n	80a21a0 <strncpy+0x16>
 80a21ac:	bd10      	pop	{r4, pc}

080a21ae <link_code_end>:
	...

080a21b0 <dynalib_user>:
 80a21b0:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a21c0:	0000 0000 724f 6569 746e 7461 6f69 206e     ....Orientation 
 80a21d0:	6553 736e 726f 5420 7365 0074 6f4f 706f     Sensor Test.Ooop
 80a21e0:	2c73 6e20 206f 4e42 304f 3535 6420 7465     s, no BNO055 det
 80a21f0:	6365 6574 2064 2e2e 202e 6843 6365 206b     ected ... Check 
 80a2200:	6f79 7275 7720 7269 6e69 2067 726f 4920     your wiring or I
 80a2210:	4332 4120 4444 2152 5800 203a 0900 3a59     2C ADDR!.X: ..Y:
 80a2220:	0020 5a09 203a 4200 4f4e 3530 0035 0000      ..Z: .BNO055...

080a2230 <_ZTV15Adafruit_BNO055>:
	...
 80a2238:	00f3 080a 01ed 080a 00f1 080a 0589 080a     ................
 80a2248:	0269 080a 0000 0000                         i.......

080a2250 <_ZTV7TwoWire>:
	...
 80a2258:	0919 080a 0963 080a 093b 080a 091b 080a     ....c...;.......
 80a2268:	0943 080a 094b 080a 0953 080a 095b 080a     C...K...S...[...

080a2278 <_ZTV9IPAddress>:
	...
 80a2280:	0a0f 080a 0a01 080a 0a03 080a 3025 3031     ............%010
 80a2290:	2075 5d00 0020 003a 6425 2c00 0020 2928     u .] .:.%d., .()
 80a22a0:	203a 2000 005b 6f63 6564 2000 203d 2500     : . [.code. = .%
 80a22b0:	0069 6564 6174 6c69 0073 005d 0a0d 6100     i.details.]....a
 80a22c0:	7070 6e00 6e61 6900 666e 6f00 6676 2e00     pp.nan.inf.ovf..
	...

080a22d8 <_ZTV8SPIClass>:
	...
 80a22e0:	0d65 080a 0d67 080a 005a 2b25 3330 3a64     e...g...Z.%+03d:
 80a22f0:	3025 7532 2500 2d59 6d25 252d 5464 4825     %02u.%Y-%m-%dT%H
 80a2300:	253a 3a4d 5325 7a25 6100 6373 6974 656d     :%M:%S%z.asctime
	...

080a2318 <_ZTV11USARTSerial>:
	...
 80a2320:	0ec9 080a 0eed 080a 0ef9 080a 0ab9 080a     ................
 80a2330:	0ed5 080a 0ee1 080a 0edb 080a 0ee7 080a     ................
 80a2340:	0ecb 080a 0ecf 080a                         ........

080a2348 <_ZL8asciimap>:
	...
 80a2350:	2b2a 0028 0000 0000 0000 0000 0000 0000     *+(.............
	...
 80a2368:	9e2c a0b4 a2a1 34a4 a7a6 aea5 2d36 3837     ,......4....6-78
 80a2378:	1e27 201f 2221 2423 2625 33b3 2eb6 b8b7     '.. !"#$%&.3....
 80a2388:	849f 8685 8887 8a89 8c8b 8e8d 908f 9291     ................
 80a2398:	9493 9695 9897 9a99 9c9b 2f9d 3031 ada3     .........../10..
 80a23a8:	0435 0605 0807 0a09 0c0b 0e0d 100f 1211     5...............
 80a23b8:	1413 1615 1817 1a19 1c1b af1d b0b1 00b5     ................

080a23c8 <_ZTV11USBKeyboard>:
	...
 80a23d0:	0f95 080a 1105 080a 10e3 080a 0ab9 080a     ................
 80a23e0:	10bd 080a 1025 080a 0f99 080a 1009 080a     ....%...........

080a23f0 <_ZTV9USBSerial>:
	...
 80a23f8:	11d5 080a 1219 080a 11f3 080a 0ab9 080a     ................
 80a2408:	11ed 080a 11d7 080a 11df 080a 1213 080a     ................
 80a2418:	11e7 080a 11d1 080a                         ........

080a2420 <_ZTVN5spark9WiFiClassE>:
	...
 80a2428:	1347 080a                                   G...

080a242c <link_const_variable_data_end>:
 80a242c:	080a00b1 	.word	0x080a00b1
 80a2430:	080a01f9 	.word	0x080a01f9
 80a2434:	080a05dd 	.word	0x080a05dd
 80a2438:	080a0859 	.word	0x080a0859
 80a243c:	080a0889 	.word	0x080a0889
 80a2440:	080a08b9 	.word	0x080a08b9
 80a2444:	080a08e9 	.word	0x080a08e9
 80a2448:	080a09d1 	.word	0x080a09d1
 80a244c:	080a0a79 	.word	0x080a0a79
 80a2450:	080a0a89 	.word	0x080a0a89
 80a2454:	080a0d35 	.word	0x080a0d35
 80a2458:	080a0d91 	.word	0x080a0d91
 80a245c:	080a0dc1 	.word	0x080a0dc1
 80a2460:	080a0df1 	.word	0x080a0df1
 80a2464:	080a0e25 	.word	0x080a0e25
 80a2468:	080a0e55 	.word	0x080a0e55
 80a246c:	080a0e69 	.word	0x080a0e69
 80a2470:	080a0e99 	.word	0x080a0e99
 80a2474:	080a1131 	.word	0x080a1131
 80a2478:	080a1199 	.word	0x080a1199
 80a247c:	080a1351 	.word	0x080a1351
 80a2480:	080a1439 	.word	0x080a1439
 80a2484:	080a1469 	.word	0x080a1469
 80a2488:	080a14d9 	.word	0x080a14d9
 80a248c:	080a1509 	.word	0x080a1509
 80a2490:	080a1585 	.word	0x080a1585
 80a2494:	080a1649 	.word	0x080a1649

080a2498 <link_constructors_end>:
	...
